This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T19:35:50.370Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.editorconfig
.gitignore
angular.json
package.json
README.md
src/app/app.component.html
src/app/app.component.ts
src/app/app.module.ts
src/app/json-typings.d.ts
src/app/services/toast.service.ts
src/app/shared/components/back-button/back-button.component.html
src/app/shared/components/back-button/back-button.component.ts
src/app/shared/components/breadcrumb-router/breadcrumb-router.component.html
src/app/shared/components/breadcrumb-router/breadcrumb-router.component.ts
src/app/shared/components/chart.component.ts
src/app/shared/components/copy-paster/copy-paster.component.html
src/app/shared/components/copy-paster/copy-paster.component.ts
src/app/shared/components/image-uploader-preview/image-uploader-preview.component.css
src/app/shared/components/image-uploader-preview/image-uploader-preview.component.html
src/app/shared/components/image-uploader-preview/image-uploader-preview.component.ts
src/app/shared/components/input/constants.ts
src/app/shared/components/input/input.component.css
src/app/shared/components/input/input.component.html
src/app/shared/components/input/input.component.ts
src/app/shared/components/linear-loading-indicator.component.ts
src/app/shared/components/monthpicker/monthpicker.component.css
src/app/shared/components/monthpicker/monthpicker.component.html
src/app/shared/components/monthpicker/monthpicker.component.ts
src/app/shared/components/search-router/search-router.component.html
src/app/shared/components/search-router/search-router.component.ts
src/app/shared/components/table/table.component.css
src/app/shared/components/table/table.component.html
src/app/shared/components/table/table.component.ts
src/app/shared/components/toasts-container/toasts-container.component.css
src/app/shared/components/toasts-container/toasts-container.component.html
src/app/shared/components/toasts-container/toasts-container.component.ts
src/app/shared/directives/ng-let.ts
src/app/shared/directives/role-based-access-control.ts
src/app/shared/directives/sortable-header.ts
src/app/shared/directives/text2mask.ts
src/app/shared/pipes/hack-case.pipe.ts
src/app/shared/pipes/highlight.pipe.ts
src/app/shared/shared.module.ts
src/app/syllogimous/components/card/card.component.html
src/app/syllogimous/components/card/card.component.scss
src/app/syllogimous/components/card/card.component.ts
src/app/syllogimous/components/modal-level-change/modal-level-change.component.html
src/app/syllogimous/components/modal-level-change/modal-level-change.component.ts
src/app/syllogimous/constants/engine.constants.ts
src/app/syllogimous/constants/local-storage.constants.ts
src/app/syllogimous/constants/syllogimous.constants.ts
src/app/syllogimous/models/question.models.ts
src/app/syllogimous/models/settings.models.ts
src/app/syllogimous/models/syllogimous.models.ts
src/app/syllogimous/pages/feedback/feedback.component.css
src/app/syllogimous/pages/feedback/feedback.component.html
src/app/syllogimous/pages/feedback/feedback.component.ts
src/app/syllogimous/pages/game/game.component.css
src/app/syllogimous/pages/game/game.component.html
src/app/syllogimous/pages/game/game.component.ts
src/app/syllogimous/pages/history/history.component.css
src/app/syllogimous/pages/history/history.component.html
src/app/syllogimous/pages/history/history.component.ts
src/app/syllogimous/pages/intro/intro.component.html
src/app/syllogimous/pages/intro/intro.component.ts
src/app/syllogimous/pages/start/start.component.css
src/app/syllogimous/pages/start/start.component.html
src/app/syllogimous/pages/start/start.component.ts
src/app/syllogimous/pages/stats/accuracy-stats/accuracy-stats.component.html
src/app/syllogimous/pages/stats/accuracy-stats/accuracy-stats.component.ts
src/app/syllogimous/pages/stats/error-analysis/error-analysis.component.html
src/app/syllogimous/pages/stats/error-analysis/error-analysis.component.ts
src/app/syllogimous/pages/stats/stats.component.html
src/app/syllogimous/pages/stats/stats.component.ts
src/app/syllogimous/pages/stats/tier-stats/tier-stats.component.html
src/app/syllogimous/pages/stats/tier-stats/tier-stats.component.ts
src/app/syllogimous/pages/stats/time-based-stats/time-based-stats.component.html
src/app/syllogimous/pages/stats/time-based-stats/time-based-stats.component.ts
src/app/syllogimous/pages/stats/type-based-stats/type-based-stats.component.html
src/app/syllogimous/pages/stats/type-based-stats/type-based-stats.component.ts
src/app/syllogimous/pages/tutorial/analogy/analogy.component.html
src/app/syllogimous/pages/tutorial/analogy/analogy.component.ts
src/app/syllogimous/pages/tutorial/binary/binary.component.html
src/app/syllogimous/pages/tutorial/binary/binary.component.ts
src/app/syllogimous/pages/tutorial/comparison-chronological/comparison-chronological.component.html
src/app/syllogimous/pages/tutorial/comparison-chronological/comparison-chronological.component.ts
src/app/syllogimous/pages/tutorial/comparison-numerical/comparison-numerical.component.html
src/app/syllogimous/pages/tutorial/comparison-numerical/comparison-numerical.component.ts
src/app/syllogimous/pages/tutorial/direction/direction.component.html
src/app/syllogimous/pages/tutorial/direction/direction.component.ts
src/app/syllogimous/pages/tutorial/direction3D/direction3D.component.html
src/app/syllogimous/pages/tutorial/direction3D/direction3D.component.ts
src/app/syllogimous/pages/tutorial/direction4D/direction4D.component.html
src/app/syllogimous/pages/tutorial/direction4D/direction4D.component.ts
src/app/syllogimous/pages/tutorial/distinction/distinction.component.html
src/app/syllogimous/pages/tutorial/distinction/distinction.component.ts
src/app/syllogimous/pages/tutorial/syllogism/syllogism.component.html
src/app/syllogimous/pages/tutorial/syllogism/syllogism.component.ts
src/app/syllogimous/pages/tutorial/tutorial.component.html
src/app/syllogimous/pages/tutorial/tutorial.component.ts
src/app/syllogimous/pages/tutorials/tutorials.component.css
src/app/syllogimous/pages/tutorials/tutorials.component.html
src/app/syllogimous/pages/tutorials/tutorials.component.ts
src/app/syllogimous/services/stats.service.ts
src/app/syllogimous/services/syllogimous.service.ts
src/app/syllogimous/syllogimous.component.html
src/app/syllogimous/syllogimous.component.scss
src/app/syllogimous/syllogimous.component.ts
src/app/syllogimous/syllogimous.module.ts
src/app/syllogimous/utils/engine.utils.ts
src/app/utils/array.ts
src/app/utils/date.ts
src/app/utils/dom.ts
src/app/utils/file.ts
src/app/utils/input.ts
src/app/utils/json.ts
src/app/utils/mask.ts
src/app/utils/number.ts
src/app/utils/object.ts
src/app/utils/promise.ts
src/app/utils/uuid.ts
src/assets/css/custom-styles/base.css
src/assets/css/custom-styles/layout.css
src/assets/css/custom-styles/module.css
src/assets/css/custom-styles/util.css
src/environments/environment.ts
src/environments/envs.ts
src/environments/versions.ts
src/index.html
src/main.ts
src/styles.css
tsconfig.app.json
tsconfig.json
tsconfig.spec.json

================================================================
Repository Files
================================================================

================
File: .editorconfig
================
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single

[*.md]
max_line_length = off
trim_trailing_whitespace = false

================
File: .gitignore
================
# See http://help.github.com/ignore-files/ for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out
/docs/*

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# Generated assets
/src/assets/css/bootstrap-with-vars.css
/src/assets/css/demos.css

# Environment files
/src/environments/environment.production.ts
/src/environments/environment.uat.ts

# Third-party dependencies
/src/app/shared/directives/deps/text2mask/*

# System files
.DS_Store
Thumbs.db

================
File: angular.json
================
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "multi-layout": {
      "projectType": "application",
      "schematics": {},
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/multi-layout",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ],
            "styles": [
              "./node_modules/bootstrap-icons/font/bootstrap-icons.css",
              "./node_modules/highlight.js/styles/magula.css",
              "./node_modules/animate.css/animate.min.css",
              "./node_modules/chartist/dist/index.css",
              "src/assets/css/bootstrap-with-vars.css",
              "src/assets/css/custom-styles/base.css",
              "src/assets/css/custom-styles/layout.css",
              "src/assets/css/custom-styles/module.css",
              "src/assets/css/custom-styles/util.css",
              "src/assets/css/demos.css",
              "src/styles.css"
            ],
            "scripts": [
              "./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js"
            ]
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "1mb",
                  "maximumError": "2mb"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kb",
                  "maximumError": "8kb"
                }
              ],
              "outputHashing": "all",
              "fileReplacements": [
                {
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.production.ts"
                }
              ]
            },
            "uat": {
              "buildOptimizer": false,
              "optimization": false,
              "vendorChunk": true,
              "extractLicenses": false,
              "sourceMap": true,
              "namedChunks": true,
              "fileReplacements": [
                {
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.uat.ts"
                }
              ]
            },
            "development": {
              "buildOptimizer": false,
              "optimization": false,
              "vendorChunk": true,
              "extractLicenses": false,
              "sourceMap": true,
              "namedChunks": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "browserTarget": "multi-layout:build:production"
            },
            "uat": {
              "browserTarget": "multi-layout:build:uat"
            },
            "development": {
              "browserTarget": "multi-layout:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n",
          "options": {
            "browserTarget": "multi-layout:build"
          }
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ],
            "styles": [
              "src/styles.css"
            ],
            "scripts": []
          }
        }
      }
    }
  },
  "cli": {
    "analytics": false
  }
}

================
File: package.json
================
{
  "name": "multi-layout",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "dev": "ng serve",
    "uat": "ng serve --configuration=uat",
    "prod": "ng serve --configuration=production",
    "build-dev": "ng build",
    "build-uat": "ng build --configuration=uat",
    "build-prod": "ng build --configuration=production",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "gh-pages": "ng build --output-path docs --base-href /Syllogimous-v4/"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^15.2.0",
    "@angular/cdk": "^15.2.2",
    "@angular/common": "^15.2.0",
    "@angular/compiler": "^15.2.0",
    "@angular/core": "^15.2.0",
    "@angular/forms": "^15.2.0",
    "@angular/platform-browser": "^15.2.0",
    "@angular/platform-browser-dynamic": "^15.2.0",
    "@angular/router": "^15.2.0",
    "@ng-bootstrap/ng-bootstrap": "^14.0.1",
    "@popperjs/core": "^2.11.6",
    "animate.css": "^4.1.1",
    "bootstrap": "^5.2.3",
    "bootstrap-icons": "^1.10.3",
    "chartist": "^1.3.0",
    "date-fns": "^2.29.3",
    "highlight.js": "^11.7.0",
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    "raw-loader": "^4.0.2",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.12.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^15.2.0",
    "@angular/cli": "~15.2.0",
    "@angular/compiler-cli": "^15.2.0",
    "@angular/localize": "^15.2.0",
    "@types/chartist": "^1.0.0",
    "@types/jasmine": "~4.3.0",
    "@types/lodash": "^4.14.197",
    "jasmine-core": "~4.5.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.1.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.0.0",
    "typescript": "~4.9.4"
  }
}

================
File: README.md
================
# Syllogimous v4

Syllogimous v4 is now available! Try it now at: [Syllogimous v4](https://4skinskywalker.github.io/Syllogimous-v4/)

## Attribution-NonCommercial 3.0 Unported (CC BY-NC 3.0)

### You are free to:
#### Share — copy and redistribute the material in any medium or format
#### Adapt — remix, transform, and build upon the material

The licensor cannot revoke these freedoms as long as you follow the license terms.

### Under the following terms:
#### Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
#### NonCommercial — You may not use the material for commercial purposes.

No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.

================
File: src/app/app.component.html
================
<app-toasts></app-toasts>

<router-outlet class="d-none"></router-outlet>

================
File: src/app/app.component.ts
================
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  title = 'Multi Layout';

  constructor() {
    const cwarn = console.warn;
    window.console.warn = (...args) => {
      if (typeof args[0] === "string" && args[0].includes("It looks like you're using the disabled attribute")) {
        return;
      }
      cwarn(...args);
    }
  }
}

================
File: src/app/app.module.ts
================
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { SharedModule } from './shared/shared.module';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
    {
        path: '',
        loadChildren: () => import('./syllogimous/syllogimous.module').then(m => m.SyllogimousModule)
    },
];

@NgModule({
    declarations: [
        AppComponent
    ],
    imports: [
        BrowserModule,
        SharedModule,
        RouterModule.forRoot(routes)
    ],
    providers: [],
    bootstrap: [AppComponent]
})
export class AppModule { }

================
File: src/app/json-typings.d.ts
================
declare module "*.json" {
    const value: any;
    export default value;
}

================
File: src/app/services/toast.service.ts
================
import { Injectable, TemplateRef } from '@angular/core';
import { guid } from '../utils/uuid';

interface IToastOptions {
	classname?: string;
	position?: "top-left" | "top-right" | "bottom-left" | "bottom-right";
	delay?: number;
}

@Injectable({ providedIn: 'root' })
export class ToastService {
    
	toasts: any[] = [];

	show(textOrTpl: string | TemplateRef<any>, options: IToastOptions = {}) {
		this.toasts.push({
			textOrTpl,
			guid: guid(),
			position: "top-right",
			...options
		});
	}

	remove(toast: any) {
		this.toasts = this.toasts.filter((t) => t !== toast);
	}

	clear() {
		this.toasts.splice(0, this.toasts.length);
	}
}

================
File: src/app/shared/components/back-button/back-button.component.html
================
<button (click)="goBack()" class="btn btn-outline-primary">
    Back
</button>

================
File: src/app/shared/components/back-button/back-button.component.ts
================
import { Component } from '@angular/core';
import { Location } from '@angular/common';

@Component({
    selector: 'app-back-button',
    templateUrl: './back-button.component.html',
    styleUrls: ['./back-button.component.css']
})
export class BackButtonComponent {

    constructor(
        private location: Location
    ) { }

    goBack() {
        this.location.back();
    }
}

================
File: src/app/shared/components/breadcrumb-router/breadcrumb-router.component.html
================
<nav class="p-3" aria-label="breadcrumb">
    <ol class="breadcrumb m-0 mb-md-3">
        <li class="breadcrumb-item" *ngFor="let segment of incrementalSegments; let last = last">
            <a class="breadcrumb-item" [routerLink]="segment.path" [class.active]="last" [class.text-decoration-none]="last">{{ segment.label }}</a>
        </li>
    </ol>
</nav>

================
File: src/app/shared/components/breadcrumb-router/breadcrumb-router.component.ts
================
import { LocationStrategy } from '@angular/common';
import { Component } from '@angular/core';

@Component({
    selector: 'app-breadcrumb-router',
    templateUrl: './breadcrumb-router.component.html',
    styleUrls: ['./breadcrumb-router.component.css']
})
export class BreadcrumbRouterComponent {

    incrementalSegments!: { label: string, path: string }[];

    constructor(
        private locationStrategy: LocationStrategy
    ) {

        // Remove baseHref to work with GitHub pages
        const baseHref = this.locationStrategy.getBaseHref();
        let pathname = location.pathname;
        if (baseHref !== '/')
            pathname = '/' + location.pathname.replaceAll(baseHref, '');

        const labels = pathname.split('/').slice(1);

        this.incrementalSegments = [];

        for (let i = 0; i < labels.length; i++) {

            const label = labels[i];
            const path = '/' + labels.slice(0, i + 1).join('/');

            this.incrementalSegments.push({ label, path });
        }
    }
}

================
File: src/app/shared/components/chart.component.ts
================
import {
    Component,
    ElementRef,
    EventEmitter,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    SimpleChanges,
} from "@angular/core";
import {
    BarChart,
    BarChartData,
    BarChartOptions,
    LineChart,
    LineChartData,
    LineChartOptions,
    PieChart,
    PieChartData,
    PieChartOptions,
    ResponsiveOptions,
} from "chartist";

type ChartTypes = BarChart | LineChart | PieChart;

export interface BarChartConfiguration {
    type: "Bar";
    data: BarChartData;
    options?: BarChartOptions;
    responsiveOptions?: ResponsiveOptions<BarChartOptions>;
}

export interface LineChartConfiguration {
    type: "Line";
    data: LineChartData;
    options?: LineChartOptions;
    responsiveOptions?: ResponsiveOptions<LineChartOptions>;
}

export interface PieChartConfiguration {
    type: "Pie";
    data: PieChartData;
    options?: PieChartOptions;
    responsiveOptions?: ResponsiveOptions<PieChartOptions>;
}

export type Configuration = BarChartConfiguration | LineChartConfiguration | PieChartConfiguration;

export interface ChartEvent {
    [eventName: string]: (data: unknown) => void;
}

@Component({
    selector: "app-chart",
    template: "",
    styles: [`
        :host {
          display: block;
        }
    `],
})
export class AppChartComponent implements OnInit, OnChanges, OnDestroy {
    @Input() configuration!: Configuration;

    // Events object where keys are Chartist event names and values are event handler functions.
    // Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
    // Event handler function will receive a data argument which contains event data.
    @Input() events!: ChartEvent;

    // Event emitted after Chartist chart has been initialized.
    // Event handler function will receive chart instance argument.
    @Output() initialized = new EventEmitter<ChartTypes>();

    chart!: ChartTypes | null;

    constructor(private elementRef: ElementRef) { }

    ngOnInit(): void {
        if (this.configuration.type && this.configuration.data) {
            this.renderChart();
        }
    }

    ngOnChanges(changes: SimpleChanges): void {
        this.update(changes);
    }

    ngOnDestroy(): void {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }

    renderChart() {
        const nativeElement = this.elementRef.nativeElement;
        const { type, data, options, responsiveOptions } = this.configuration;

        if (type === "Bar") {
            this.chart = new BarChart(
                nativeElement,
                data,
                options,
                responsiveOptions,
            );
        } else if (type === "Line") {
            this.chart = new LineChart(
                nativeElement,
                data,
                options,
                responsiveOptions,
            );
        } else if (type === "Pie") {
            this.chart = new PieChart(
                nativeElement,
                data,
                options,
                responsiveOptions,
            );
        } else {
            throw new Error(`${type} is not a known chart type`);
        }

        if (this.events) {
            this.bindEvents();
        }

        this.initialized.emit(this.chart);
    }

    update(changes: SimpleChanges): void {
        const { type, data, options } = this.configuration;

        if (!type || !data) {
            return;
        }

        const changedConfiguration = changes.configuration
            .currentValue as Configuration;

        if (!this.chart || changedConfiguration.type !== type) {
            this.renderChart();
        } else if (
            "data" in changedConfiguration ||
            "options" in changedConfiguration
        ) {
            this.chart.update(data, options);
        }
    }

    bindEvents(): void {
        for (const event of Object.keys(this.events)) {
            this.chart?.on(event, this.events[event]);
        }
    }
}

================
File: src/app/shared/components/copy-paster/copy-paster.component.html
================
<button class="btn btn-primary" (click)="copy()">
    {{ hasCopied ? 'Copied!' : 'Copy' }}
</button>

================
File: src/app/shared/components/copy-paster/copy-paster.component.ts
================
import { Component, Input } from '@angular/core';

@Component({
    selector: 'app-copy-paster',
    templateUrl: './copy-paster.component.html',
    styleUrls: ['./copy-paster.component.css']
})
export class CopyPasterComponent {

    @Input("value") value!: string;

    hasCopied = false;

    copy() {

        const selBox = document.createElement('textarea');
        selBox.style.position = 'fixed';
        selBox.style.left = '0';
        selBox.style.top = '0';
        selBox.style.opacity = '0';
        selBox.value = this.value;

        document.body.appendChild(selBox);

        selBox.focus();
        selBox.select();

        document.execCommand('copy');
        document.body.removeChild(selBox);

        this.hasCopied = true;
        setTimeout(() => this.hasCopied = false, 3000)
    }
}

================
File: src/app/shared/components/image-uploader-preview/image-uploader-preview.component.css
================
:host, .uploader {
    display: grid;
}

.uploader {
    margin: 0 auto;
    max-width: 600px;
    width: 100%;
}

.uploader label {
    width: 100%;
    padding: 1.5rem;
    text-align: center;
    background: #fff;
    border-radius: var(--border-radius_md);
    border: 3px solid #eee;
    transition: all 0.2s ease;
    user-select: none;
}

.uploader label:hover {
    border-color: rgba(var(--app-primary_500), 1);
}

.uploader label.hover {
    border: 3px solid rgba(var(--app-primary_500), 1);
    box-shadow: inset 0 0 0 6px #eee;
}

.uploader label.hover #start i.fa {
    transform: scale(0.8);
    opacity: 0.3;
}

.uploader #start {
    float: left;
    clear: both;
    width: 100%;
}

.uploader #start.hidden {
    display: none;
}

.uploader #start i.fa {
    font-size: 50px;
    margin-bottom: 1rem;
    transition: all 0.2s ease-in-out;
}

.uploader #response {
    float: left;
    clear: both;
    width: 100%;
}

.uploader #response.hidden {
    display: none;
}

.uploader #response #messages {
    margin-bottom: 0.5rem;
}

.uploader #file-image {
    display: inline;
    margin: 0 auto 0.5rem auto;
    width: auto;
    height: auto;
    max-width: 180px;
}

.uploader #file-image.hidden {
    display: none;
}

.uploader input[type=file] {
    display: none;
}

.uploader div {
    margin: 0 0 0.5rem 0;
    color: #5f6982;
}

================
File: src/app/shared/components/image-uploader-preview/image-uploader-preview.component.html
================
<form
    #fileUploadForm
    id="file-upload-form"
    class="uploader"
    [class.not-clickable]="disabled"
>

    <input
        id="file-upload"
        type="file"
        name="fileUpload"
        accept="image/*"
        (change)="fileSelectHandler($event)"
    />

    <label
        #fileDrag
        [class.d-none]="fileDragHidden"
        for="file-upload"
        id="file-drag"
        (dragover)="fileDragHover($event)"
        (dragleave)="fileDragHover($event)"
        (drop)="fileSelectHandler($event)"
    >

        <img
            id="file-image"
            alt="Preview"
            [src]="
                base64
                    ? 'data:image/png;base64,' + base64
                    : '#'
            "
            [class.hidden]="!base64"
        >

        <div id="start" [class.hidden]="base64">

            <i
                class="fa fa-download"
                [class.fa-download]="!disabled"
                [class.fa-picture-o]="disabled"
            ></i>

            <div>
                {{
                    disabled
                        ? "Image is not present"
                        : "Select an image or drag here"
                }}
            </div>
            
            <span
                *ngIf="!disabled"
                id="file-upload-btn"
                class="btn btn-primary shadow"
            >
                Select an image
            </span>
        </div>

        <div class="text-center">
            <button
                *ngIf="!disabled && base64"
                class="btn btn-danger shadow"
                (click)="reset($event)"
            >
                Remove image
            </button>
        </div>
    </label>
</form>

================
File: src/app/shared/components/image-uploader-preview/image-uploader-preview.component.ts
================
import { Component, ElementRef, EventEmitter, Input, Output, ViewChild } from "@angular/core";
import { ToastService } from "src/app/services/toast.service";

export function formatBytes(bytes: number, decimals = 2) {

    if (!+bytes) return '0 Bytes';

    const k = 1000;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}

interface Base64Details {
    filetype: string;
    size: number;
    filename: string;
    base64: string;
}

@Component({
    selector: "app-image-uploader-preview",
    templateUrl: "./image-uploader-preview.component.html",
    styleUrls: [ "./image-uploader-preview.component.css" ]
})
export class ImageUploaderPreviewComponent {

    @ViewChild("fileUploadForm") fileUploadForm!: ElementRef;
    @ViewChild("fileDrag") fileDrag!: ElementRef;
    
    @Input("base64") base64: string | null = null;
    @Input("maxSize") maxSize = 1000000;
    @Input("fileDragHidden") fileDragHidden = false;
    @Input("disabled") disabled = false;

    @Output("onImageChange") onImageChange = new EventEmitter<string | null>();

    constructor(
        private toaster: ToastService
    ) { }

    fileSelectHandler(e: Event) {

        // Fetch FileList object
        const element = e.target as HTMLInputElement;
        const files: FileList | null = element.files || (e as any).dataTransfer.files;
        const file = (files || [])[0];
    
        // Cancel event and hover styling
        this.fileDragHover(e);

        this.parseFile(file);
    }

    fileDragHover(e: Event) {
    
        e.stopPropagation();
        e.preventDefault();

        const dragEl = this.fileDrag.nativeElement;
        dragEl.className = e.type === "dragover"
            ? "hover"
            : "modal-body file-upload";
    }

    async parseFile(file: File) {
  
        const extCheck = /\.(?=gif|jpg|png|jpeg)/gi.test(file.name);
        const fileDetails = await this.getFileBase64(file);
    
        if (!extCheck) {
            const message = "The file provided is not supported.";
            console.error(message);
            this.toaster.show(message, { classname: "bg-danger text-light"});
            this.reset();
        }
        else if (fileDetails.size > this.maxSize) {
            const message = `The image provided exceeds ${formatBytes(this.maxSize)}.`;
            console.error(message);
            this.toaster.show(message, { classname: "bg-danger text-light"});
            this.reset();
        }
        else {
            this.base64 = fileDetails.base64;
            this.onImageChange.emit(this.base64);
        }
    }

    reset(e?: Event) {

        this.base64 = null;
        this.onImageChange.emit(this.base64);

        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }

        if (this.fileUploadForm) {
            this.fileUploadForm.nativeElement.reset();
        }
    }

    getFileBase64(file: File): Promise<Base64Details>{
        return new Promise((resolve) => {

            const details: any = {}

            details.filetype = file.type;
            details.size = file.size;
            details.filename = file.name;

            const reader = new FileReader();
            reader.onload = (e: any) => {
                const  base64 = btoa(e.target?.result);
                details.base64 = base64;
                resolve(details);
            };

            reader.readAsBinaryString(file);
        })
    }

}

================
File: src/app/shared/components/input/constants.ts
================
import { ControlValueAccessor } from "@angular/forms";

export const DUMMY_VALUE_ACCESSOR: ControlValueAccessor = {
    writeValue() { },
    registerOnChange() { },
    registerOnTouched() { }
};

export const supportedTypes = [
    "text",
    "textarea",
    "password",
    "number",
    "year",
    "date",
    "time",
    "datetime",
    "select",
    "checkbox",
    "radio",
    "autocomplete",
    "tagger"
];

export const defaultLimitTextFactory = (limit: number) => {
    return "Limited to " + limit + " items, type for more results.";
}

export const defaultFormatter = (item: any, index: number): any => {
    if (typeof item === "object") {
        return Object.values(item).join(" ");
    }
    else if (typeof item === "string") {
        return item;
    }
    return "";
};

export const defaultFilter = (term: string, item: any) => {
    if (typeof item === "object") {
        const stringifiedValues = JSON.stringify(Object.values(item)).toLowerCase();
        return stringifiedValues.includes(term.toLowerCase());
    }
    else if (typeof item === "string") {
        return item.toLowerCase().includes(term.toLowerCase());
    }
    else {
        return true;
    }
};

================
File: src/app/shared/components/input/input.component.css
================
:host {
    display: block;
}

.reset-field {
    cursor: pointer;
    position: absolute;
    right: 0.75rem;
    line-height: 1;
}

.invalid-feedback:not(:empty) ~ .reset-field {
    right: 2rem;
}

.reset-field:has(~ .invalid-feedback:not(:empty)) {
    right: 2rem;
}

.reset-field.reset-field--floating {
    top: 1.325rem;
}

.reset-field.reset-field--fixed {
    top: 0.675rem;
}

.tagger-array {
    border: 1px dashed #ccc;
    border-radius: 0.25rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    padding: 0.375rem;
}

.tagger-array:empty::before {
    content: "Selected items will be shown here";
    color: #ccc;
}

================
File: src/app/shared/components/input/input.component.html
================
<ng-template #invalidFeedback let-ngControl>
    <div class="invalid-feedback">

        <ng-container *ngIf="!onlyCustomErrors">

            <div *ngIf="ngControl.errors?.min">
                Minimum {{ ngControl.errors?.min.min }}
            </div>
    
            <div *ngIf="ngControl.errors?.max">
                Maximum {{ ngControl.errors?.max.max }}
            </div>
    
            <div *ngIf="ngControl.errors?.required">
                Required
            </div>
    
            <div *ngIf="ngControl.errors?.email">
                Invalid email
            </div>
    
            <div *ngIf="ngControl.errors?.minlength">
                Minimum length {{ ngControl.errors?.minlength.requiredLength }}
            </div>
    
            <div *ngIf="ngControl.errors?.maxlength">
                Maximum length {{ ngControl.errors?.maxlength.requiredLength }}
            </div>
    
            <div *ngIf="ngControl.errors?.pattern">
                Invalid format
            </div>
        </ng-container>

        <ng-content select="[customErrors]"></ng-content>
    </div>
</ng-template>

<ng-container *ngIf="floatingLabel; else fixedLabel">

    <div *ngIf="type === 'text'" class="form-floating">

        <ng-container *ngIf="mask; else withoutMask">
            <input
                [class.pseudo-disabled]="disabled"
                [tabindex]="disabled ? -1 : 0"
                [class.is-invalid]="isInvalid()"
                [textMask]="{ mask }"
                [formControl]="ngControl"
                type="text"
                class="form-control"
                [id]="_name"
                [placeholder]="placeholder"
                [minlength]="minLength"
                [maxlength]="maxLength"
            >
        </ng-container>
        <ng-template #withoutMask>
            <input
                [class.pseudo-disabled]="disabled"
                [tabindex]="disabled ? -1 : 0"
                [class.is-invalid]="isInvalid()"
                [formControl]="ngControl"
                type="text"
                class="form-control"
                [id]="_name"
                [placeholder]="placeholder"
                [minlength]="minLength"
                [maxlength]="maxLength"
            >
        </ng-template>

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

        <i
            *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
            class="reset-field reset-field--floating bi bi-x-lg"
            (click)="ngControl.setValue(null)"
        ></i>
    </div>

    <div *ngIf="type === 'password'" class="form-floating">

        <input
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            type="password"
            class="form-control"
            [id]="_name"
            [placeholder]="placeholder"
            [minlength]="minLength"
            [maxlength]="maxLength"
        >

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

        <i
            *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
            class="reset-field reset-field--floating bi bi-x-lg"
            (click)="ngControl.setValue(null)"
        ></i>
    </div>

    <div *ngIf="type === 'number'" class="form-floating">

        <input
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            type="number"
            class="form-control"
            [id]="_name"
            [placeholder]="placeholder"
            [step]="step"
            [min]="min"
            [max]="max"
        >

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'textarea'" class="form-floating">

        <textarea
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-control"
            [id]="_name"
            [placeholder]="placeholder"
            [minlength]="minLength"
            [maxlength]="maxLength"
            style="height: 100px"
        ></textarea>

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'select'" class="form-floating">

        <select
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-select"
            [id]="_name"
        >
            <option
                *ngFor="let opt of options"
                [ngValue]="opt.value"
                [disabled]="opt.disabled"
            >
                {{ opt.text }}
            </option>
        </select>

        <label [for]="disabled ? 'nowhere' : _name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'year'" class="form-floating">

        <select
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-select"
            [id]="_name"
        >
            <option
                *ngFor="let opt of yearOptions"
                [ngValue]="opt.value"
            >
                {{ opt.text }}
            </option>
        </select>

        <label [for]="disabled ? 'nowhere' : _name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'date'" class="form-floating">

        <input
            type="date"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
            [min]="min"
            [max]="max"
        />

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>
    
    <div *ngIf="type === 'time'" class="form-floating">

        <input
            type="time"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
        />

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>
    
    <div *ngIf="type === 'datetime'" class="form-floating">

        <input
            type="datetime-local"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
            [min]="min"
            [max]="max"
        />

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'autocomplete'" class="form-floating position-relative">

        <input
            type="text"
            class="form-control"
            [ngClass]="'autocomplete-' + guid"
            #instance="ngbTypeahead"
            [id]="_name"
            [class.is-invalid]="isInvalid()" 
            [placeholder]="placeholder" 
            [ngbTypeahead]="search"
            [inputFormatter]="$any(formatter)"
            [resultFormatter]="$any(formatter)"
            [resultTemplate]="template"
            [editable]="false"
            [disabled]="disabled"
            [(ngModel)]="autocompleteChoice"
            (focus)="focus$.next($any($event).target.value)"
            (click)="onAutocompleteClick(instance, $event)"
            (change)="markAsTouched()"
            (blur)="markAsTouched()"
            (selectItem)="selectItem($event)"
        />

        <label [for]="_name">{{ label }}</label>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

        <i
            *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
            class="reset-field reset-field--floating bi bi-x-lg"
            (click)="ngControl.setValue(null)"
        ></i>
    </div>

    <div *ngIf="type === 'tagger'">

        <div class="tagger-array">
            <span
                *ngFor="let tag of tags; let i = index"
                class="badge d-flex align-items-center fs-6 rounded-pill bg-secondary"
            >

                <div>{{ formatter(tag, i) }}</div>

                <button
                    type="button"
                    class="btn p-0 lh-0 fs-6 text-white"
                    (click)="removeTag(tag)"
                >
                    <i class="bi bi-x"></i>
                </button>
            </span>
        </div>
    
        <div class="form-floating position-relative">
    
            <input
                type="text"
                class="form-control"
                [ngClass]="'autocomplete-' + guid"
                #instance="ngbTypeahead"
                [id]="_name"
                [class.is-invalid]="isInvalid()"
                [placeholder]="placeholder"
                [ngbTypeahead]="search"
                [inputFormatter]="$any(formatter)"
                [resultFormatter]="$any(formatter)"
                [resultTemplate]="template"
                [editable]="false"
                [disabled]="disabled"
                [(ngModel)]="autocompleteChoice"
                (focus)="focus$.next($any($event).target.value)"
                (click)="onAutocompleteClick(instance, $event)"
                (change)="markAsTouched()"
                (blur)="markAsTouched()"
                (selectItem)="taggerChoiceSelected($event)"
                (keyup.enter)="freeTagOnEnter($event)"
            />
    
            <label [for]="_name">{{ label }}</label>
        
            <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
        </div>
    </div>
</ng-container>

<ng-template #fixedLabel>

    <div *ngIf="type === 'text'">

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <div class="position-relative">

            <ng-container *ngIf="mask; else withoutMask">
                <input
                    [class.pseudo-disabled]="disabled"
                    [tabindex]="disabled ? -1 : 0"
                    [class.is-invalid]="isInvalid()"
                    [textMask]="{ mask }"
                    [formControl]="ngControl"
                    type="text"
                    class="form-control"
                    [id]="_name"
                    [placeholder]="placeholder"
                    [minlength]="minLength"
                    [maxlength]="maxLength"
                >
            </ng-container>
            <ng-template #withoutMask>
                <input
                    [class.pseudo-disabled]="disabled"
                    [tabindex]="disabled ? -1 : 0"
                    [class.is-invalid]="isInvalid()"
                    [formControl]="ngControl"
                    type="text"
                    class="form-control"
                    [id]="_name"
                    [placeholder]="placeholder"
                    [minlength]="minLength"
                    [maxlength]="maxLength"
                >
            </ng-template>

            <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

            <i
                *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
                class="reset-field reset-field--fixed bi bi-x-lg"
                (click)="ngControl.setValue(null)"
            ></i>
        </div>
    </div>

    <div *ngIf="type === 'password'">

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <div class="position-relative">

            <input
                [class.pseudo-disabled]="disabled"
                [tabindex]="disabled ? -1 : 0"
                [class.is-invalid]="isInvalid()"
                [formControl]="ngControl"
                type="password"
                class="form-control"
                [id]="_name"
                [placeholder]="placeholder"
                [minlength]="minLength"
                [maxlength]="maxLength"
            >

            <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

            <i
                *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
                class="reset-field reset-field--fixed bi bi-x-lg"
                (click)="ngControl.setValue(null)"
            ></i>
        </div>
    </div>

    <div *ngIf="type === 'number'">

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <input
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            type="number"
            class="form-control"
            [id]="_name"
            [placeholder]="placeholder"
            [step]="step"
            [min]="min"
            [max]="max"
        >

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'textarea'">

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <textarea
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-control"
            [id]="_name"
            [placeholder]="placeholder"
            [minlength]="minLength"
            [maxlength]="maxLength"
            rows="3"
        ></textarea>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'select'">

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <select
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-select"
            [id]="_name"
        >
            <option
                *ngFor="let opt of options"
                [ngValue]="opt.value"
                [disabled]="opt.disabled"
            >
                {{ opt.text }}
            </option>
        </select>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'year'" >

        <label *ngIf="label" [for]="disabled ? 'nowhere' : _name" class="form-label">{{ label }}</label>

        <select
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [formControl]="ngControl"
            class="form-select"
            [id]="_name"
        >
            <option
                *ngFor="let opt of yearOptions"
                [ngValue]="opt.value"
            >
                {{ opt.text }}
            </option>
        </select>

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'date'" >

        <label *ngIf="label" class="form-label" [for]="disabled ? 'nowhere' : _name">{{ label }}</label>

        <input
            type="date"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
            [min]="min"
            [max]="max"
        />

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>
    
    <div *ngIf="type === 'time'" >

        <label *ngIf="label" class="form-label" [for]="disabled ? 'nowhere' : _name">{{ label }}</label>

        <input
            type="time"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
        />

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>
    
    <div *ngIf="type === 'datetime'" >

        <label *ngIf="label" class="form-label" [for]="disabled ? 'nowhere' : _name">{{ label }}</label>

        <input
            type="datetime-local"
            class="form-control"
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [id]="_name"
            [name]="name"
            [formControl]="ngControl"
            [min]="min"
            [max]="max"
        />

        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>

    <div *ngIf="type === 'autocomplete'">

        <label *ngIf="label" class="form-label" [for]="_name">{{ label }}</label>

        <div class="position-relative">

            <input
                type="text"
                class="form-control"
                [ngClass]="'autocomplete-' + guid"
                #instance="ngbTypeahead"
                [id]="_name"
                [class.is-invalid]="isInvalid()"
                [placeholder]="placeholder"
                [ngbTypeahead]="search"
                [inputFormatter]="$any(formatter)"
                [resultFormatter]="$any(formatter)"
                [resultTemplate]="template"
                [editable]="false"
                [disabled]="disabled"
                [(ngModel)]="autocompleteChoice"
                (focus)="focus$.next($any($event).target.value)"
                (click)="onAutocompleteClick(instance, $event)"
                (change)="markAsTouched()"
                (blur)="markAsTouched()"
                (selectItem)="selectItem($event)"
            />

            <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>

            <i
                *ngIf="ngControl.value && ngControl.status !== 'DISABLED' && !disabled"
                class="reset-field reset-field--fixed bi bi-x-lg"
                (click)="ngControl.setValue(null)"
            ></i>
        </div>
    </div>

    <div *ngIf="type === 'tagger'">

        <label class="form-label" *ngIf="label" [for]="_name">{{ label }}</label>
    
        <div class="tagger-array">
            <span
                *ngFor="let tag of tags; let i = index"
                class="badge d-flex align-items-center fs-6 rounded-pill bg-secondary"
            >

                <div>{{ formatter(tag, i) }}</div>

                <button
                    type="button"
                    class="btn p-0 lh-0 fs-6 text-white"
                    (click)="removeTag(tag)"
                >
                    <i class="bi bi-x"></i>
                </button>
            </span>
        </div>
    
        <input
            type="text"
            class="form-control"
            [ngClass]="'autocomplete-' + guid"
            #instance="ngbTypeahead"
            [id]="_name"
            [class.is-invalid]="isInvalid()"
            [placeholder]="placeholder"
            [ngbTypeahead]="search"
            [inputFormatter]="$any(formatter)"
            [resultFormatter]="$any(formatter)"
            [resultTemplate]="template"
            [editable]="false"
            [disabled]="disabled"
            [(ngModel)]="autocompleteChoice"
            (focus)="focus$.next($any($event).target.value)"
            (click)="onAutocompleteClick(instance, $event)"
            (change)="markAsTouched()"
            (blur)="markAsTouched()"
            (selectItem)="taggerChoiceSelected($event)"
            (keyup.enter)="freeTagOnEnter($event)"
        />
    
        <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
    </div>
</ng-template>

<div *ngIf="type === 'checkbox'" class="form-check">

    <input
        [class.pseudo-disabled]="disabled"
        [tabindex]="disabled ? -1 : 0"
        [class.is-invalid]="isInvalid()"
        [formControl]="ngControl"
        class="form-check-input"
        type="checkbox"
        [id]="_name"
    >

    <label
        *ngIf="label"
        class="form-check-label"
        [for]="disabled ? 'nowhere' : _name"
    >
      {{ label }}
    </label>

    <ng-container *ngTemplateOutlet="invalidFeedback; context: { $implicit: ngControl }"></ng-container>
</div>

<div *ngIf="type === 'radio'">
    <div *ngFor="let opt of options" class="form-check">

        <input
            [class.pseudo-disabled]="disabled"
            [tabindex]="disabled ? -1 : 0"
            class="form-check-input"
            [value]="opt.value"
            type="radio"
            [name]="name"
            [id]="opt._id"
        >

        <label
            class="form-check-label"
            [for]="disabled ? 'nowhere' : opt._id"
        >
          {{ opt.text }}
        </label>
    </div>
</div>

<div *ngIf="helper" class="form-text">{{ helper }}</div>

================
File: src/app/shared/components/input/input.component.ts
================
import { Component, EventEmitter, Input, OnDestroy, OnInit, Optional, Output, Self, SimpleChanges } from '@angular/core';
import { ControlContainer, FormControl, FormGroupDirective, NgControl } from '@angular/forms';
import { NgbTypeahead, NgbTypeaheadSelectItemEvent } from '@ng-bootstrap/ng-bootstrap';
import { isEqual } from 'lodash';
import { BehaviorSubject, debounceTime, distinctUntilChanged, filter, map, merge, Observable, OperatorFunction, Subject, takeUntil } from 'rxjs';
import { guid } from 'src/app/utils/uuid';
import { DUMMY_VALUE_ACCESSOR, defaultFilter, defaultFormatter, defaultLimitTextFactory, supportedTypes } from './constants';

export interface SelectOption {
    value: any;
    text: string;
    disabled?: boolean;
}

@Component({
    selector: 'app-input',
    templateUrl: './input.component.html',
    styleUrls: ['./input.component.css'],
    providers: [{
        provide: ControlContainer,
        useExisting: FormGroupDirective
    }]
})
export class InputComponent implements OnInit, OnDestroy {

    destroy$ = new Subject<void>();

    guid!: string;
    _name!: string;

    currYear = new Date().getFullYear();
    yearPlusMinus = 6; // Example: 2017 ... 2023 ... 2029
    yearOptions: SelectOption[] = this.getYearOptions();

    @Input("floatingLabel") floatingLabel = false;
    @Input("feedback") feedback = true;
    @Input("disabled") disabled = false;
    @Input("type") type = "text";
    @Input("placeholder") placeholder = ' ';
    @Input("onlyCustomErrors") onlyCustomErrors = false;

    @Input("step") step?: any;

    min?: any;
    @Input("min")
    set _min(val: any) {
        this.min = val;
        this.yearOptions = this.getYearOptions(true);
    }

    max?: any;
    @Input("max") 
    set _max(val: any) {
        this.max = val;
        this.yearOptions = this.getYearOptions(true);
    }

    @Input("minlength") minLength?: any;
    @Input("maxlength") maxLength?: any;

    @Input("name") name!: string;
    @Input("label") label?: string;
    @Input("helper") helper!: string;
    @Input("mask") mask?: Array<string | RegExp>;
    @Input("ngControl") ngControl!: FormControl;

    // Autocomplete and tagger properties
    @Input("deduped") deduped = true;
    @Input("freeTag") freeTag = false;
    @Input("limit") limit: false | number = false;
    @Input("limitTextFactory") limitTextMaker = defaultLimitTextFactory;
    @Input("formatter") formatter = defaultFormatter;
    @Input("filter") filter = defaultFilter;
    @Input("template") template!: any;
    @Output("selectItem") selectItemEmitter = new EventEmitter<NgbTypeaheadSelectItemEvent>();

    @Input("customSearch") customSearch!: OperatorFunction<string, readonly any[]>;
    search!: OperatorFunction<string, readonly any[]>;
    instance!: NgbTypeahead;
    focus$ = new Subject<string>();
    click$ = new Subject<string>();

    _autocompleteChoice!: any;
    set autocompleteChoice(value: any) {
        this._autocompleteChoice = value;
        this.onAutocompleteChange(value);
    }
    get autocompleteChoice() {
        return this._autocompleteChoice;
    }

    options$ = new BehaviorSubject<any[] | null>(null);
    @Input("options")
    set options(options: any[] | null) {
        this.options$.next(options);
    };
    get options() {
        if (this.freeTag) {
            return [];
        }
        return this.options$.getValue();
    };

    tags: any[] = [];

    constructor(@Self() @Optional() private formControlName: NgControl) {
        if (this.formControlName) {
            this.formControlName.valueAccessor = DUMMY_VALUE_ACCESSOR;
        }
    }

    ngOnInit() {

        // Provide compatibility with formControlName directive
        if (!this.ngControl && this.formControlName) {
            this.ngControl = this.formControlName.control as FormControl;
        }

        this.handleErrors();

        this.guid = guid();
        this._name = this.name + "-" + this.guid;

        this.addOptionIds();

        if (this.type === "autocomplete") {
            this.setAutocompleteDefault();
            this.setAutocompleteSearch();
            this.setAutocompleteReactivity();
        }
        if (this.type === "tagger") {
            this.setTaggerDefault();
            this.setAutocompleteSearch();
            this.setTaggerReactivity();
        }
        if (["autocomplete", "tagger"].includes(this.type) && this.limit) {
            this.appendLimitExplainerStylesheet();
        }

        // Sync this.disabled value to ngControl status
        if (this.ngControl.disabled) {
            this.disabled = true;
        }
        this.ngControl.statusChanges
            .pipe(
                takeUntil(this.destroy$),
                map(status => status === "DISABLED"),
                filter(disabled => this.disabled !== disabled)
            )
            .subscribe(disabled => {
                this.disabled = disabled;
            });
    }

    ngOnChanges(changes: SimpleChanges) {
        // Sync ngControl status with this.disabled value
        if (changes.disabled && this.ngControl) {
            if (changes.disabled.currentValue) {
                this.ngControl.disable({ onlySelf: true, emitEvent: false });
            }
            else {
                this.ngControl.enable({ onlySelf: true, emitEvent: false });
            }
        }
    }

    ngOnDestroy() {
        this.destroy$.next();
        if (["autocomplete", "tagger"].includes(this.type) && this.limit) {
            this.removeLimitExplainerStylesheet();
        }
    }

    handleErrors() {
        if (!supportedTypes.includes(this.type)) {
            throw Error("Type " + this.type + " is not supported.");
        }
        if (!this.ngControl) {
            throw Error("app-input needs a ngControl");
        }
        if (!this.name) {
            throw Error("app-input needs a name");
        }
        if (this.type === "select" || this.type === "radio") {
            if (!this.options || this.options && !Array.isArray(this.options)) {
                throw Error("Select and radio need the options array");
            }
        }
        if (this.type === "autocomplete" && !this.customSearch) {
            if (!this.options || this.options && !Array.isArray(this.options)) {
                throw Error("Autocomplete without a custom search needs the options array");
            }
        }
        if (this.type === "tagger" && !this.freeTag) {
            if (!this.options || this.options && !Array.isArray(this.options)) {
                throw Error("Tagger without a free tag needs the options array");
            }
        }
    }

    isInvalid() {
        return this.ngControl.touched && this.ngControl.errors;
    }

    getYearOptions(fromSetter = false) {

        if (fromSetter && this.type !== "year") {
            return [];
        }

        // Dynamically create the list of years
        const min = this.min ? parseInt(this.min) : this.currYear - this.yearPlusMinus;
        const max = this.max ? parseInt(this.max) : this.currYear + this.yearPlusMinus;

        if (max < min) {
            throw new Error('"max" cannot be less than "min"');
        }

        return Array(max - min)
            .fill(0)
            .map((_, index) => min + index)
            .map((year) => ({ text: year + "", value: year }));
    }

    //  █████╗ ██╗   ██╗████████╗ ██████╗  ██████╗ ██████╗ ███╗   ███╗██████╗ ██╗     ███████╗████████╗███████╗
    // ██╔══██╗██║   ██║╚══██╔══╝██╔═══██╗██╔════╝██╔═══██╗████╗ ████║██╔══██╗██║     ██╔════╝╚══██╔══╝██╔════╝
    // ███████║██║   ██║   ██║   ██║   ██║██║     ██║   ██║██╔████╔██║██████╔╝██║     █████╗     ██║   █████╗  
    // ██╔══██║██║   ██║   ██║   ██║   ██║██║     ██║   ██║██║╚██╔╝██║██╔═══╝ ██║     ██╔══╝     ██║   ██╔══╝  
    // ██║  ██║╚██████╔╝   ██║   ╚██████╔╝╚██████╗╚██████╔╝██║ ╚═╝ ██║██║     ███████╗███████╗   ██║   ███████╗
    // ╚═╝  ╚═╝ ╚═════╝    ╚═╝    ╚═════╝  ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝   ╚═╝   ╚══════╝
    appendLimitExplainerStylesheet() {
        // Create CSS for description
        const css =
`input[role="combobox"].autocomplete-${this.guid} + ngb-typeahead-window::before {
    content: "${this.limitTextMaker(this.limit as number)}";
    white-space: pre;
    color: #888;
    display: block;
    font-size: 0.9rem;
    padding: 0 10px 5px;
    text-align: center;
}`;
        // Create stylesheet
        const style = document.createElement("style");
        style.id = "autocomplete-" + this.guid;
        style.appendChild(document.createTextNode(css));
        // Append stylesheet to head
        const head = document.getElementsByTagName("head")[0];
        head.appendChild(style);
    }

    removeLimitExplainerStylesheet() {
        const el = document.getElementById("autocomplete-" + this.guid)!;
        el.remove();
    }

    // Add an ids to options in order to differentiate radios
    addOptionIds() {
        this.options$
            .pipe(takeUntil(this.destroy$))
            .subscribe(options => {
                if (this.type === "radio" && options && Array.isArray(options)) {
                    options.forEach(opt => opt._id = this.name + "-" + guid());
                }
            });
    }

    setAutocompleteSearch() {
        this.search = (text$: Observable<string>) => {

            const debouncedText$ = text$.pipe(debounceTime(200), distinctUntilChanged());
            const clicksWithClosedPopup$ = this.click$.pipe(filter(() => !this.instance.isPopupOpen()));
            const inputFocus$ = this.focus$;

            const combined$ = merge(debouncedText$, inputFocus$, clicksWithClosedPopup$);

            let searchObs$;
            if (this.customSearch) {
                searchObs$ = this.customSearch(combined$);
            }
            else {
                searchObs$ = combined$
                    .pipe(
                        map((term: string) => {
                            if (this.options) {
                                return this.options.filter(value => this.filter(term, value));
                            }
                            return [];
                        })
                    );
            }

            if (this.limit) {
                return searchObs$.pipe(map(array => array.slice(0, this.limit as number)));
            }

            return searchObs$;
        };
    };

    setAutocompleteDefault() {
        if (this.ngControl.value) {
            this.autocompleteChoice = this.ngControl.value;
        }
    }

    setAutocompleteReactivity() {
        this.ngControl.valueChanges
            .pipe(takeUntil(this.destroy$))
            .subscribe(value => {
                this._autocompleteChoice = value;
            });
    }

    onAutocompleteChange(value: any) {

        const input = document.getElementById(this._name);
        if (this.isInvalid()) {
            input?.classList.add("is-invalid");
        }
        else {
            input?.classList.remove("is-invalid");
        }

        if (this.type !== "tagger" && this.ngControl.value !== value) {
            this.ngControl.setValue(value);
        }
    }

    onAutocompleteClick(instance: NgbTypeahead, event: any) {
        this.instance = instance;
        this.click$.next(event.target.value);
    }

    selectItem(selectEvent: NgbTypeaheadSelectItemEvent) {
        this.selectItemEmitter.emit(selectEvent);
    }

    // ████████╗ █████╗  ██████╗  ██████╗ ███████╗██████╗ 
    // ╚══██╔══╝██╔══██╗██╔════╝ ██╔════╝ ██╔════╝██╔══██╗
    //    ██║   ███████║██║  ███╗██║  ███╗█████╗  ██████╔╝
    //    ██║   ██╔══██║██║   ██║██║   ██║██╔══╝  ██╔══██╗
    //    ██║   ██║  ██║╚██████╔╝╚██████╔╝███████╗██║  ██║
    //    ╚═╝   ╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝╚═╝  ╚═╝
    setTaggerDefault() {
        if (this.ngControl.value) {
            this.tags = this.ngControl.value;
        }
    }

    setTaggerReactivity() {
        this.ngControl.valueChanges
            .pipe(
                takeUntil(this.destroy$),
                filter(tags => Array.isArray(tags))
            )
            .subscribe(tags => {
                this.tags = tags;
            });
    }

    taggerChoiceSelected(value: any) {
        if (this.deduped && this.tags?.some(tag => isEqual(tag, value.item))) {
            console.warn("Entry already present");
        }
        else {
            this.ngControl.setValue([...this.tags, value.item]);
        }
        setTimeout(() => this._autocompleteChoice = null, 0);
    }

    freeTagOnEnter(event: any) {

        if (!this.freeTag) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();

        const value = event.target.value;
        if (value === "") {
            return;
        }

        const trimmed = value.trim();
        if (this.deduped && this.tags.some(tag => isEqual(tag, trimmed))) {
            console.warn("Entry already present");
        }
        else {
            this.ngControl.setValue([...this.tags, trimmed]);
        }
        setTimeout(() => this._autocompleteChoice = null, 0);
    }

    removeTag(item: any) {
        const itemIndex = this.tags.lastIndexOf(item);
        if (itemIndex > -1) {
            this.ngControl.setValue([
                ...this.tags.slice(0, itemIndex),
                ...this.tags.slice(itemIndex + 1)
            ]);
            setTimeout(() => this._autocompleteChoice = null, 0);
        }
    }

    markAsTouched() {
        this.ngControl.markAsTouched();
    }
}

================
File: src/app/shared/components/linear-loading-indicator.component.ts
================
import { Component, Input } from '@angular/core';
import { delay } from 'src/app/utils/promise';

const size = 32;
const spacing = 8;

@Component({
	selector: 'app-linear-loading-indicator',
	template: `
        <div class="lli-list">
            <div
                *ngFor="let char of chars"
                class="lli-item"
            >
                {{ char }}
            </div>
        </div>
	`,
    styles: [`

        .lli-list {
            position: relative;
            height: ${size}px;
            margin: 0 auto;
        }

        .lli-item {
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            display: grid;
            place-items: center;
            background: rgba(var(--app-primary_500), 1);
            box-shadow: 0 0 10px #0002;
            color: rgba(var(--app-gray_0), 1);
            font-weight: bold;
            top: 0px;
            left: 0px;
            text-transform: uppercase;
            transition:
                border-radius 300ms ease,
                top 300ms ease,
                left 300ms ease;
        }

        .lli-item.lli-item--active {
            background: rgba(var(--app-primary_200), 1);
            border-radius: 50%;
            top: -40px;
        }
    `]
})
export class LinearLoadingIndicatorComponent {

    _text = "loading";
    @Input("text")
    set text(value: string) {
        this._text = value;
        this.chars = value.split("");
    }

    chars = this._text.split("");

    i = 0;
    stop = false;
    lliList!: any[];
    positions!: number[];
	
	ngAfterViewInit() {

        // Get items
        this.lliList = [ ...document.querySelectorAll(".lli-item") as any ];

        // Set parent width
        (document.querySelector(".lli-list") as any).style.width = (this.lliList.length * size + (this.lliList.length - 1) * spacing) + "px";

        // Calculate left offsets
        this.positions = Array(this.lliList.length).fill(0).map((_, index) => index * (size + spacing));

        this.loop();
    }

    ngOnDestroy() {
        this.stop = true;
    }

    async loop() {

        // Avoid infinite loop
        if (this.stop) return;

        // Set initial positions
        for (let j = 0; j < this.lliList.length; j++) {
            this.lliList[(j + this.i) % this.lliList.length].style.left = this.positions[j] + "px";
        }

        await delay(300);

        // Set active (raise it)
        const active = this.lliList[this.i % this.lliList.length];
        active.classList.add("lli-item--active");

        // Shift elements to the left
        for (let j = 0; j < this.lliList.length; j++) {
            await delay(300);
            this.lliList[(j + this.i + 1) % this.lliList.length].style.left = this.positions[j] + "px";
        }

        // Shift active element to the end
        active.style.left = this.positions[this.lliList.length - 1] + "px";

        // Remove active state (lower it)
        await delay(300);
        active.classList.remove("lli-item--active");

        // Rinse and repeat
        this.i++;
        this.loop();
    }
}

================
File: src/app/shared/components/monthpicker/monthpicker.component.css
================
.highlight {
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.app-monthpicker {
    position: relative;
}

.app-monthpicker__toggle {
    position: absolute;
    inset: 0 0 0 0;
}

.app-monthpicker__toggle::after {
    all: unset !important;
}

.app-monthpicker__reset-icon,
.app-monthpicker__calendar-icon {
    cursor: pointer;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 1;
}

.app-monthpicker__reset-icon {
    right: 2.25rem;
}

.app-monthpicker__calendar-icon {
    right: 0.75rem;
}

.app-month-picker__input.is-invalid ~ .app-monthpicker__reset-icon {
    right: 3.75rem;
}

.app-month-picker__input.is-invalid ~ .app-monthpicker__calendar-icon {
    right: 2.25rem;
}

================
File: src/app/shared/components/monthpicker/monthpicker.component.html
================
<ng-template #mpInputTemplate>
    <input
        #mp
        class="app-month-picker__input form-control"
        (focus)="openDropdown($event); blur()"
        (keypress)="$event.preventDefault()"
        [class.form-control-sm]="size === 'sm'"
        [class.form-control-lg]="size === 'lg'"
        [class.pseudo-disabled]="disabled"
        [class.is-invalid]="touched && ngControl.errors"
        [name]="name"
        [placeholder]="placeholder"
        [formControl]="ngControl"
    >
</ng-template>

<div #dd="ngbDropdown" ngbDropdown>

    <label
        *ngIf="label && !floatingLabel"
        class="form-label"
        (click)="openDropdown($event)"
    >
        {{ label }}
    </label>

    <div class="app-monthpicker">

        <div 
            *ngIf="!disabled"
            class="app-monthpicker__toggle"
            ngbDropdownToggle
        ></div>

        <ng-container *ngIf="floatingLabel; else fixedLabel">
            <div class="form-floating">
                <ng-container *ngTemplateOutlet="mpInputTemplate"></ng-container>
                <label>{{ label }}</label>
            </div>
        </ng-container>
        <ng-template #fixedLabel>
            <ng-container *ngTemplateOutlet="mpInputTemplate"></ng-container>
        </ng-template>
    
        <i
            *ngIf="ngControl.value"
            class="app-monthpicker__reset-icon bi bi-x-lg"
            (click)="reset($event)"
        ></i>

        <i
            class="app-monthpicker__calendar-icon bi bi-calendar3"
            (click)="openDropdown($event)"
        ></i>
    </div>

    <div class="invalid-feedback" [class.d-block]="touched && ngControl.errors">
        <div *ngIf="ngControl.errors?.required">
            Required
        </div>
    </div>

    <div class="dropdown-menu p-3" ngbDropdownMenu>

        <div *ngIf="!removeYear" class="d-grid mb-3" style="justify-items: center;">
            <select class="form-select" style="max-width: 7.5rem;" (change)="onYearSelected($event)">
                <option
                    *ngFor="let y of years"
                    [selected]="y.selected"
                    [value]="y.year"
                >
                    {{ y.year }}
                </option>
            </select>
        </div>

        <div class="d-grid gap-2" style="grid-template-columns: repeat(3, 1fr);">
            <button
                *ngFor="let m of months"
                class="btn btn-outline-primary text-uppercase"
                [class.highlight]="m.current"
                [disabled]="m.disabled"
                (click)="onMonthSelected(m.number)"
            >
                {{ m.name }}
            </button>
        </div>
    </div>
</div>

<div *ngIf="helper" class="form-text">{{ helper }}</div>

================
File: src/app/shared/components/monthpicker/monthpicker.component.ts
================
import { Component, ElementRef, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { FormControl } from '@angular/forms';
import { NgbDropdown } from '@ng-bootstrap/ng-bootstrap';
import { Subject, takeUntil } from 'rxjs';
import { blur } from 'src/app/utils/dom';

export interface MonthpickerStruct {
    year: number;
    month: number;
}

@Component({
    selector: 'app-monthpicker',
    templateUrl: './monthpicker.component.html',
    styleUrls: ['./monthpicker.component.css']
})
export class MonthpickerComponent {

    years: { selected: boolean, year: number }[] = [];

    months: { disabled: boolean, current: boolean, number: number, name: string }[] = [];

    today = new Date();
    currYear = this.today.getFullYear();
    currMonth = this.today.getMonth();

    year = this.currYear;

    touched = false;
    destroy$ = new Subject<void>();

    blur = blur;

    @ViewChild("dd") dropdown!: NgbDropdown;
    @ViewChild("mp") monthpicker!: ElementRef<HTMLInputElement>;

    @Input("ngControl") ngControl!: FormControl<MonthpickerStruct | null>;
    @Input("size") size: "sm" | "md" | "lg" = "md";
    @Input("name") name!: string;
    @Input("label") label?: string;
    @Input("placeholder") placeholder = "yyyy-mm";
    @Input("helper") helper?: string;
    @Input("disabled") disabled = false;
    @Input("floatingLabel") floatingLabel = false;
    @Input("lookahead") lookahead = 10;
    @Input("lookbehind") lookbehind = 10;
    @Input("removeYear") removeYear = false;

    monthNames: string[] = [];

    minDate?: MonthpickerStruct | null;
    @Input("minDate")
    set _minDate(v: MonthpickerStruct | null) {

        // The default year selection when minDate.year is future
        // is exactly minDate.year therefore this.year has to
        // be moved forward
        if (v && v.year > this.year) {
            this.year = v.year;
        }

        this.minDate = v;
        this.updateMonthpickerModel();
    }

    maxDate?: MonthpickerStruct | null;
    @Input("maxDate")
    set _maxDate(v: MonthpickerStruct | null) {

        // The default year selection when maxDate.year is past
        // is exactly maxDate.year therefore this.year has to
        // be moved backward
        if (v && v.year < this.year) {
            this.year = v.year;
        }

        this.maxDate = v;
        this.updateMonthpickerModel();
    }

    @Output("monthSelect") monthSelectEmitter = new EventEmitter<MonthpickerStruct | null>();

    ngOnInit() {

        // Construct monthNames
        for (let month = 0; month < 12; month++) {
            const date = new Date(this.year, month, 1);
            const monthName = date.toLocaleString("default", { month: "long" });
            this.monthNames.push(monthName);
        }

        this.handleErrors();
        this.updateMonthpickerModel();
    }

    ngAfterViewInit() {

        if (this.ngControl.value) {
            this.setMonthpickerInputValue(this.ngControl.value);
        }

        this.ngControl.valueChanges
            .pipe(takeUntil(this.destroy$))
            .subscribe(value => this.setMonthpickerInputValue(value));
    }

    setMonthpickerInputValue(value: MonthpickerStruct | null) {

        if (!value) {
            this.monthpicker.nativeElement.value = "";
            return;
        }

        const { year, month } = value;
        const inputText = (this.removeYear)
            ? this.monthNames[month - 1]
            : year + "-" + month;
        this.monthpicker.nativeElement.value = inputText;
    }

    ngOnDestroy() {
        this.destroy$.next();
    }

    handleErrors() {

        if (!this.ngControl)
            throw Error("app-monthpicker needs a ngControl.");

        if (!this.name)
            throw Error("app-monthpicker needs a name.");
    }

    updateMonthpickerModel() {
        this.createYears();
        this.createMonths();
    }

    createYears() {

        this.years = [];

        const start = this.minDate?.year || this.currYear - this.lookbehind;
        const end = this.maxDate?.year || this.currYear + this.lookahead;

        for (let year = start; year <= end; year++) {
            this.years.push({
                selected: year === this.year,
                year
            });
        }
    }

    createMonths() {

        this.months = [];

        for (let month = 0; month < 12; month++) {

            const monthName = (this.monthNames[month] || "NA").slice(0, 3);

            const aboveMax = this.maxDate && (this.maxDate.year < this.year || this.maxDate.year === this.year && this.maxDate.month < month + 1) || false;
            const belowMin = this.minDate && (this.minDate.year > this.year || this.minDate.year === this.year && this.minDate.month > month + 1) || false;

            this.months.push({
                disabled: aboveMax || belowMin,
                current: this.year === this.currYear && month === this.currMonth,
                number: month + 1,
                name: monthName
            });
        }
    }

    onYearSelected(evt: any) {
        this.year = +evt.target.value;
        this.months = [];
        this.createMonths();
    }

    onMonthSelected(monthNumber: number) {
        this.touched = true;
        const selection = {
            year: (this.removeYear) ? 0 : this.year,
            month: monthNumber
        };
        this.monthSelectEmitter.emit(selection);
        this.ngControl.setValue(selection);
        this.dropdown.close();
    }

    reset(evt: Event) {
        evt.stopPropagation();
        if (this.disabled) return;
        this.ngControl.setValue(null);
    }

    openDropdown(evt: Event) {
        evt.stopPropagation();
        if (this.disabled) return;
        this.dropdown.open();
    }
}

================
File: src/app/shared/components/search-router/search-router.component.html
================
<app-input
    type="autocomplete"
    name="component"
    label="Search a component ⌕"
    [floatingLabel]="true"
    [options]="searchRoutes"
    [formatter]="cmpFormatter"
    [template]="rt"
    [ngControl]="cmpControl"
></app-input>
<ng-template #rt let-r="result" let-t="term">
    <div [routerLink]="r.path">
        <ngb-highlight style="font-size: 1.05rem;" [result]="r.title" [term]="t"></ngb-highlight>
        <div style="font-size: 0.8rem; padding-left: 0.25rem; margin-bottom: 0.25rem;">{{ r.path }}</div>
    </div>
</ng-template>

================
File: src/app/shared/components/search-router/search-router.component.ts
================
import { Component, Input } from '@angular/core';
import { FormControl } from '@angular/forms';
import { Router } from '@angular/router';
import { filter, tap } from 'rxjs';

export interface SearchRoute {
    title: string;
    path: string;
}

@Component({
    selector: 'app-search-router',
    templateUrl: './search-router.component.html',
    styleUrls: ['./search-router.component.css']
})
export class SearchRouterComponent {

    @Input("searchRoutes") searchRoutes!: SearchRoute[];

    cmpControl = new FormControl();
    cmpFormatter = (cmp: any) => cmp.title;

    constructor(
        private router: Router
    ) {

        this.cmpControl.valueChanges
            .pipe(
                filter(value => !!value),
                tap(value => this.router.navigateByUrl(value.path))
            )
            .subscribe();
    }
}

================
File: src/app/shared/components/table/table.component.css
================
:host {
    display: block;
}

:host ::ng-deep .ngb-highlight {
    background-color: #ff0;
}

:host ::ng-deep th {
    white-space: nowrap;
}

.table {
    margin-bottom: 0;
    vertical-align: middle;
}

.animated {
    animation: forwards ease-out 300ms FadeIn;
    filter: blur(2px);
    left: -5px;
    opacity: 0;
    position: relative;
}

.animated:nth-child(1) { animation-delay: 20ms }
.animated:nth-child(2) { animation-delay: 40ms }
.animated:nth-child(3) { animation-delay: 60ms }
.animated:nth-child(4) { animation-delay: 80ms }
.animated:nth-child(5) { animation-delay: 100ms }
.animated:nth-child(6) { animation-delay: 120ms }
.animated:nth-child(7) { animation-delay: 140ms }
.animated:nth-child(8) { animation-delay: 160ms }
.animated:nth-child(9) { animation-delay: 180ms }
.animated:nth-child(10) { animation-delay: 200ms }
.animated:nth-child(11) { animation-delay: 220ms }
.animated:nth-child(12) { animation-delay: 240ms }
.animated:nth-child(13) { animation-delay: 260ms }
.animated:nth-child(14) { animation-delay: 280ms }
.animated:nth-child(15) { animation-delay: 300ms }
.animated:nth-child(16) { animation-delay: 320ms }
.animated:nth-child(17) { animation-delay: 340ms }
.animated:nth-child(18) { animation-delay: 360ms }
.animated:nth-child(19) { animation-delay: 380ms }
.animated:nth-child(20) { animation-delay: 400ms }
.animated:nth-child(21) { animation-delay: 420ms }
.animated:nth-child(22) { animation-delay: 440ms }
.animated:nth-child(23) { animation-delay: 460ms }
.animated:nth-child(24) { animation-delay: 480ms }
.animated:nth-child(25) { animation-delay: 500ms }
.animated:nth-child(26) { animation-delay: 520ms }
.animated:nth-child(27) { animation-delay: 540ms }
.animated:nth-child(28) { animation-delay: 560ms }
.animated:nth-child(29) { animation-delay: 580ms }
.animated:nth-child(30) { animation-delay: 600ms }
.animated:nth-child(31) { animation-delay: 620ms }
.animated:nth-child(32) { animation-delay: 640ms }
.animated:nth-child(33) { animation-delay: 660ms }
.animated:nth-child(34) { animation-delay: 680ms }
.animated:nth-child(35) { animation-delay: 700ms }
.animated:nth-child(36) { animation-delay: 720ms }
.animated:nth-child(37) { animation-delay: 740ms }
.animated:nth-child(38) { animation-delay: 760ms }
.animated:nth-child(39) { animation-delay: 780ms }
.animated:nth-child(40) { animation-delay: 800ms }
.animated:nth-child(41) { animation-delay: 820ms }
.animated:nth-child(42) { animation-delay: 840ms }
.animated:nth-child(43) { animation-delay: 860ms }
.animated:nth-child(44) { animation-delay: 880ms }
.animated:nth-child(45) { animation-delay: 900ms }
.animated:nth-child(46) { animation-delay: 920ms }
.animated:nth-child(47) { animation-delay: 940ms }
.animated:nth-child(48) { animation-delay: 960ms }
.animated:nth-child(49) { animation-delay: 980ms }
.animated:nth-child(50) { animation-delay: 1000ms }

@keyframes FadeIn {
    from {
        filter: blur(2px);
        left: -5px;
        opacity: 0;
    }
    to {
        filter: blur(0px);
        left: 0;
        opacity: 1;
    }
}

.row-expand {
    background: #0000 !important;
    border: none;
    padding: 0 !important;
}

.collapse-toggle::after {
    content: '\F283';
    display: inline-block;
    font-family: bootstrap-icons !important;
    font-style: normal;
    font-weight: normal !important;
    font-variant: normal;
    text-transform: none;
    line-height: 1;
    vertical-align: -0.125em;
}

.collapse-toggle[aria-expanded="true"]::after {
    content: '\F27D';
}

.collapse-toggle.collapsed::after {
    content: '\F283';
}

tfoot {
    background: rgba(var(--app-gray_800), 1);
    color: rgba(var(--app-gray_0), 1)
}

.sticky-head {
    background: rgba(var(--app-gray_0), 1);
    box-shadow: 0 2px 16px 0 #0002;
    position: sticky;
    top: 0;
    z-index: 1;
}

@media (max-width: 650px) {

    thead {
        display: none;
    }
    
    :host ::ng-deep td {
        display: grid;
    }

    :host ::ng-deep td::before {
        content: attr(data-label);
        font-weight: bold;
    }
}

@media (min-width: 650px) {

    :host ::ng-deep .table > thead > tr > th:first-child,
    :host ::ng-deep .table > tbody > tr > td:not(.row-expand):first-child {
        padding-left: 1.5rem !important;
    }

    :host ::ng-deep .table > thead > tr > th:last-child,
    :host ::ng-deep .table > tbody > tr > td:not(.row-expand):last-child {
        padding-right: 1.5rem !important;
    }
}

================
File: src/app/shared/components/table/table.component.html
================
<ng-template #paginationTemplate>
	<div class="d-flex flex-wrap justify-content-center gap-2">
	
		<ngb-pagination
			[collectionSize]="collectionSize"
			[(page)]="page"
			[pageSize]="pageSize"
			(pageChange)="paginate()"
			[maxSize]="3"
			[rotate]="true"
			[boundaryLinks]="true"
		></ngb-pagination>
	
		<select
			class="form-select"
			style="width: auto"
			[(ngModel)]="pageSize"
			(ngModelChange)="paginate()"
		>
			<option *ngFor="let ps of pageSizes" [ngValue]="ps">{{ ps }}</option>
		</select>
	</div>
</ng-template>

<div
	*ngIf="searchable || paginated"
	class="d-flex justify-content-center justify-content-lg-between flex-wrap gap-2 p-3 mb-2"
>

	<div>
		<app-input
			*ngIf="searchable"
			style="max-width: 250px"
			[ngControl]="searchInput"
			[name]="'search-input-' + _guid"
			placeholder="Search ⌕"
		></app-input>
	</div>

	<div
		*ngIf="paginated"
		class="d-flex flex-wrap justify-content-center gap-2"
	>
		<ng-container *ngTemplateOutlet="paginationTemplate" />
	</div>
</div>

<div class="table-responsive" [ngStyle]="{ 'max-height': maxHeight }">
	<table class="table table-striped" [style.table-layout]="tableFixed ? 'fixed' : null">
	
		<thead [class.sticky-head]="stickyHead">
			<tr>
	
				<th *ngIf="selectable" style="width: 60px">
					<div class="form-check">
						<input
							class="form-check-input"
							type="checkbox"
							(change)="
								$any($event.currentTarget).checked
									? onEveryRowSelect()
									: onEveryRowDeselect()
							"
						>
					</div>
				</th>

				<th *ngIf="rowExpand" style="width: 60px"></th>
	
				<ng-container *ngTemplateOutlet="thead"></ng-container>
			</tr>
		</thead>
	
		<tbody>

			<ng-container *ngFor="let item of paginatedItems$ | async; let i = index; trackBy: trackByFn">
				<ng-container *ngLet="{ collapsed: true } as _row">
					
					<tr [class.animated]="animated">
			
						<td *ngIf="selectable">
							<div class="form-check">
								<input
									class="form-check-input"
									type="checkbox"
									[(ngModel)]="item._selected"
									(change)="
										$any($event.currentTarget).checked
											? onRowSelect(item)
											: onRowDeselect(item)
									"
								>
							</div>
						</td>
	
						<td *ngIf="rowExpand">
							<button
								type="button"
								class="btn collapse-toggle"
								(click)="_row.collapsed = !_row.collapsed"
								[attr.aria-expanded]="!_row.collapsed"
								aria-controls="collapseExample"
							></button>
						</td>
			
						<ng-container
							*ngTemplateOutlet="
								tbody;
								context: {
									$implicit: item,
									index: i,
									term$: lastTerm$
								}
							"
						></ng-container>
					</tr>
	
					<tr *ngIf="rowExpand">
						<td class="row-expand" [attr.colspan]="colspan + (rowExpand ? 1 : 0)">
							<div #collapse="ngbCollapse" [(ngbCollapse)]="_row.collapsed">
								<ng-container
									*ngTemplateOutlet="
										rowExpand;
										context: {
											$implicit: item,
											index: i,
											term$: lastTerm$
										}
									"
								></ng-container>
							</div>
						</td>
					</tr>
	
					<tr *ngIf="rowExpand" class="hidden"></tr>
				</ng-container>
			</ng-container>

			<td *ngIf="!(paginatedItems$ | async)?.length" [attr.colspan]="colspan + (rowExpand ? 1 : 0)">
				<ng-container *ngIf="emptyTemplate; else showEmptyMessage">
					<ng-container *ngTemplateOutlet="emptyTemplate"></ng-container>
				</ng-container>
				<ng-template #showEmptyMessage>
					<div class="p-3 text-center">{{ emptyMessage }}</div>
				</ng-template>
			</td>
		</tbody>

		<tfoot *ngIf="tfoot && (showFootIfEmpty || (paginatedItems$ | async)?.length)">
			<tr>
				<ng-container *ngTemplateOutlet="tfoot"></ng-container>
			</tr>
		</tfoot>
	</table>
</div>

<div
	*ngIf="duplicateControls && (searchable || paginated)"
	class="d-flex justify-content-center justify-content-lg-between flex-wrap gap-2 p-3"
>

	<div>
		<app-input
			*ngIf="searchable"
			style="max-width: 250px"
			[ngControl]="searchInputRelay"
			[name]="'search-input-relay-' + _guid"
			placeholder="Search ⌕"
		></app-input>
	</div>

	<div
		*ngIf="paginated"
		class="d-flex flex-wrap justify-content-center gap-2"
	>
		<ng-container *ngTemplateOutlet="paginationTemplate" />
	</div>
</div>

================
File: src/app/shared/components/table/table.component.ts
================
import { Component, ContentChildren, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output, QueryList, SimpleChanges, TemplateRef } from '@angular/core';
import { FormControl } from '@angular/forms';
import { BehaviorSubject, merge, Subject, takeUntil, tap } from 'rxjs';
import { resolve } from 'src/app/utils/object';
import { guid } from 'src/app/utils/uuid';
import { AppSortableHeader, compare, SortDirection, SortEvent } from '../../directives/sortable-header';

@Component({
    selector: 'app-table',
    templateUrl: './table.component.html',
    styleUrls: ['./table.component.css']
})
export class TableComponent implements OnInit, OnChanges, OnDestroy {

    destroy$ = new Subject<void>();

    _guid = "app-table-" + guid();

    @Input("thead") thead!: TemplateRef<any>;
    @Input("tbody") tbody!: TemplateRef<any>;
    @Input("animated") animated = false;
    @Input("rowExpand") rowExpand!: TemplateRef<any>;
    @Input("tfoot") tfoot!: TemplateRef<any>;
    @Input("showFootIfEmpty") showFootIfEmpty = false;
    @Input("items") items!: any[];
    @Input("trackByFn") trackByFn = (index: number, item: any): any => item;
    @Input("emptyTemplate") emptyTemplate?: TemplateRef<any>;
    @Input("emptyMessage") emptyMessage: string = "No results to display";
    @Input("stickyHead") stickyHead = false;
    @Input("maxHeight") maxHeight: string | boolean = false;

    @Input("tableFixed") tableFixed = false;
    @Input("colspan") colspan = 99;

    // Search and pagination fields
    @Input("searchable") searchable: string[] | boolean = false;
    @Input("paginated") paginated = false;
    @Input("pageSize") pageSize = 5;
    @Input("pageSizes") pageSizes = [ 5, 10, 25, 50 ];
    @Input("duplicateControls") duplicateControls = false;

    paginatedItems$ = new BehaviorSubject<any[]>([]);
    collectionSize!: number;
    page = 1;

    searchInput = new FormControl("", { nonNullable: true });
    searchInputRelay = new FormControl("", { nonNullable: true });
    lastTerm$ = new BehaviorSubject("");
    filteredItems: any[] = [];

    // Sorting fields
    @ContentChildren(AppSortableHeader) headers!: QueryList<AppSortableHeader>;
    lastColumn = "";
    lastDirection: SortDirection = "";
    sortedItems: any[] = [];

    // Selectable fields
    @Input("selectable") selectable = false;
    get selectedRows() {
        return this.paginatedItems$.getValue()
            .filter(item => item._selected);
    }

    @Output("rowSelected") rowSelected = new EventEmitter<any>();
    @Output("rowDeselected") rowDeselected = new EventEmitter<any>();

    ngOnInit() {

        if (!this.thead) {
            throw Error("AppTable needs a thead template");
        }

        if (!this.tbody) {
            throw Error("AppTable needs a tbody template");
        }

        if (!this.items || this.items && !Array.isArray(this.items)) {
            throw Error("AppTable needs the items array");
        }

        // Double controls needs to keep the two search inputs in-sync
        const [a, b] = [this.searchInput, this.searchInputRelay];
        const opt = {
            onlySelf: true,
            emitEvent: false,
            emitModelToViewChange: true
        };
        a.valueChanges.subscribe(v => b.setValue(v, opt));
        b.valueChanges.subscribe(v => a.setValue(v, opt));

        // Set reactive search on both search controls
        merge(a.valueChanges, b.valueChanges)
            .pipe(
                takeUntil(this.destroy$),
                tap(term => {
                    this.lastTerm$.next(term);
                    this.search();
                }),
            )
            .subscribe();
    }

    ngOnChanges(changes: SimpleChanges) {
        if ("items" in changes) {

            const previousItems = changes.items.previousValue;
            const items = changes.items.currentValue;

            if (!items || !Array.isArray(items)) {
                console.warn("Items must have a value and be an array.");
            }
            else if (previousItems !== items) {
                if (!this.paginated) this.pageSize = items.length;
                this.collectionSize = items.length;
                this.search();
            }
        }
    }

    ngOnDestroy() {
        this.destroy$.next();
    }

    search() {
        this.filter();
        this.sort({
            column: this.lastColumn,
            direction: this.lastDirection
        });
    }

    filter() {

        const term = (this.lastTerm$.getValue() || "").toLowerCase();

        this.filteredItems = this.items.filter(item => {

            // Targeted search by fields provided in searchable array
            if (this.searchable && Array.isArray(this.searchable) && this.searchable.length) {
                return this.searchable.some(path =>
                    ((resolve(path, item) || "") + "").toLowerCase().includes(term)
                );
            }

            // Global hacky search
            const serialized = JSON.stringify(item).toLowerCase();
            return serialized.includes(term);
        });

        this.collectionSize = this.filteredItems.length;
    }

    sort({ column, direction }: SortEvent) {

        if (!this.headers) {
            this.sortedItems = this.filteredItems;
            this.paginate();
            return;
        }

        // Reset others column direction
        this.headers.forEach(header => {
            if (header.sortable !== column) {
                header.direction = "";
            }
        });

        if (column === "" || direction === "") {
            this.sortedItems = this.filteredItems;
        }
        else {
            this.sortedItems = [...this.filteredItems]
                .sort((a, b) => {

                    const compared = compare(
                        resolve(column, a),
                        resolve(column, b)
                    );

                    return direction === "asc" ? compared : -compared;
                });
        }

        this.lastColumn = column;
        this.lastDirection = direction;

        this.paginate();
    }

    paginate() {

        // Deselect items (to prevent keeping items not in view selected)
        this.sortedItems.forEach(item => item._selected = false);

        const slice = this.sortedItems.slice(
            (this.page - 1) * this.pageSize,
            (this.page - 1) * this.pageSize + this.pageSize,
        );

        this.paginatedItems$.next(slice);
    }

    onRowSelect(item: any) {
        this.rowSelected.emit(item);
    }

    onRowDeselect(item: any) {
        this.rowDeselected.emit(item);
    }

    onEveryRowSelect() {
        const items = this.paginatedItems$.getValue();
        items.forEach(item => item._selected = true);
    }

    onEveryRowDeselect() {
        const items = this.paginatedItems$.getValue();
        items.forEach(item => item._selected = false);
    }
}

================
File: src/app/shared/components/toasts-container/toasts-container.component.css
================
:host {
    position: relative;
    z-index: 9999;
}

================
File: src/app/shared/components/toasts-container/toasts-container.component.html
================
<ng-template #toastTemplate let-toasts="toasts" let-position="position">
    <ng-container *ngFor="let toast of toasts; let i = index; trackBy: trackById">
        <ngb-toast
            *ngIf="toast.position === position"
            style="font-size: 1.15rem; width: 500px;"
            [class]="toast.classname"
            [autohide]="true"
            [delay]="toast.delay || 5000"
            (hidden)="toastService.remove(toast)"
        >
            <div class="d-flex align-items-start">
        
                <div style="flex: 1 0 0;">
        
                    <ng-template [ngIf]="isTemplate(toast)" [ngIfElse]="text">
                        <ng-template [ngTemplateOutlet]="toast.textOrTpl"></ng-template>
                    </ng-template>
        
                    <ng-template #text>{{ toast.textOrTpl }}</ng-template>
                </div>
        
                <span style="cursor: pointer;" (click)="deleteToast(i)"><i class="bi bi-x-lg"></i></span>
            </div>
        </ngb-toast>
    </ng-container>
</ng-template>

<div class="toast-container position-fixed top-0 start-0 p-3">
    <ng-container *ngTemplateOutlet="toastTemplate; context: {
        toasts: this.toastService.toasts,
        position: 'top-left'
    }"></ng-container>
</div>

<div class="toast-container position-fixed top-0 end-0 p-3">
    <ng-container *ngTemplateOutlet="toastTemplate; context: {
        toasts: this.toastService.toasts,
        position: 'top-right'
    }"></ng-container>
</div>

<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <ng-container *ngTemplateOutlet="toastTemplate; context: {
        toasts: this.toastService.toasts,
        position: 'bottom-right'
    }"></ng-container>
</div>

<div class="toast-container position-fixed bottom-0 start-0 p-3">
    <ng-container *ngTemplateOutlet="toastTemplate; context: {
        toasts: this.toastService.toasts,
        position: 'bottom-left'
    }"></ng-container>
</div>

================
File: src/app/shared/components/toasts-container/toasts-container.component.ts
================
import { Component, TemplateRef } from '@angular/core';
import { ToastService } from '../../../services/toast.service';

@Component({
	selector: 'app-toasts',
	templateUrl: "./toasts-container.component.html",
	styleUrls: [ "./toasts-container.component.css" ]
})
export class ToastsContainer {
	
	constructor(public toastService: ToastService) {}

	isTemplate(toast: any) {
		return toast.textOrTpl instanceof TemplateRef;
	}

	deleteToast(index: number) {
		this.toastService.toasts.splice(index, 1);
	}

	filterToasts(position: "top-left" | "top-right" | "bottom-left" | "bottom-right") {
		return this.toastService.toasts.filter(t => t.position === position)
	}

	trackById(index: number, toast: { guid: string }): string {
		return toast.guid;
	}
}

================
File: src/app/shared/directives/ng-let.ts
================
import { Directive, Input, TemplateRef, ViewContainerRef } from "@angular/core";

@Directive({
    selector: '[ngLet]'
})
export class LetDirective {

    private ctx = { ngLet: null };

    constructor(
        vcr: ViewContainerRef,
        tr: TemplateRef<any>
    ) {
        vcr.createEmbeddedView(tr, this.ctx);
    }

    @Input()
    set ngLet(value: any) {
        this.ctx.ngLet = value;
    }
}

================
File: src/app/shared/directives/role-based-access-control.ts
================
import { Directive, Input, OnDestroy, OnInit, TemplateRef, ViewContainerRef } from "@angular/core";
import { Subscription } from "rxjs";
import { User } from "src/app/models/user";
import { AuthService } from "src/app/services/auth.service";
import { intersection } from "src/app/utils/array";

@Directive({
    selector:"[rbac]"
})
export class RBACDirective implements OnInit, OnDestroy {

    @Input("rbac")
    set rbacAllow(allowedRoles: string[]) {
        this.allowedRoles = allowedRoles;
        this.showIfUserAllowed();
    }

    initialized = false;
    user: User | null = null;
    sub!: Subscription;
    allowedRoles!: string[];

    constructor(
        private authService: AuthService,
        private templateRef: TemplateRef<any>,
        private viewContainer: ViewContainerRef
    ) { }

    ngOnInit() {
        this.sub = this.authService.user$
            .subscribe(user => {
                if (!user) return;
                this.user = user;
                this.showIfUserAllowed();
            });
    }

    ngOnDestroy() {
        this.sub.unsubscribe();
    }

    showIfUserAllowed() {
        if (this.initialized) {
            this.viewContainer.clear();
        }

        if (
            !this.user ||
            !this.allowedRoles ||
            this.allowedRoles.length === 0 ||
            !(intersection(this.allowedRoles, this.user.roles).length > 0)
        ) {
            this.viewContainer.clear();
        }
        else {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.initialized = true;
        }
    }

}

================
File: src/app/shared/directives/sortable-header.ts
================
import { Directive, EventEmitter, Input, Output } from "@angular/core";

export type SortDirection = 'asc' | 'desc' | '';
const rotate: { [key: string]: SortDirection } = { asc: 'desc', desc: '', '': 'asc' };

export function compare(v1: string | number, v2: string | number) {

	// Let's put non values on top of the comparison
	const v1IsNonValue = v1 === null || v1 === undefined;
	const v2IsNonValue = v2 === null || v2 === undefined;

	if (v1IsNonValue && v2IsNonValue) return 0;
	if (v1IsNonValue) return -1;
	if (v2IsNonValue) return 1;

    return (v1 < v2 ? -1 : v1 > v2 ? 1 : 0);
}

export interface SortEvent {
	column: string;
	direction: SortDirection;
}

@Directive({
	selector: 'th[sortable]',
	host: {
		'[class.asc]': 'direction === "asc"',
		'[class.desc]': 'direction === "desc"',
		'(click)': 'rotate()',
	},
})
export class AppSortableHeader {

	@Input() sortable = '';
	@Input() direction: SortDirection = '';
	@Output() sort = new EventEmitter<SortEvent>();

	rotate() {
		this.direction = rotate[this.direction];
		this.sort.emit({ column: this.sortable, direction: this.direction });
	}
}

================
File: src/app/shared/directives/text2mask.ts
================
import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, Renderer2, SimpleChanges } from '@angular/core'
import { NG_VALUE_ACCESSOR, ControlValueAccessor, COMPOSITION_BUFFER_MODE } from '@angular/forms'
import { ɵgetDOM as getDOM } from '@angular/platform-browser'
import { createTextMaskInputElement } from './deps/text2mask/textMaskCore'

export class TextMaskConfig {
  mask!: Array<string | RegExp> | ((raw: string) => Array<string | RegExp>) | false
  guide?: boolean
  placeholderChar?: string
  pipe?: (conformedValue: string, config: TextMaskConfig) => false | string | object
  keepCharPositions?: boolean
  showMask?: boolean
}

export const MASKEDINPUT_VALUE_ACCESSOR: Provider = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MaskedInputDirective),
  multi: true
}

/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid(): boolean {
  const userAgent = getDOM() ? getDOM().getUserAgent() : ''
  return /android (\d+)/.test(userAgent.toLowerCase())
}

@Directive({
  host: {
    '(input)': '_handleInput($event.target.value)',
    '(blur)': 'onTouched()',
    '(compositionstart)': '_compositionStart()',
    '(compositionend)': '_compositionEnd($event.target.value)'
  },
  selector: '[textMask]',
  exportAs: 'textMask',
  providers: [MASKEDINPUT_VALUE_ACCESSOR]
})
export class MaskedInputDirective implements ControlValueAccessor, OnChanges {
  @Input('textMask') textMaskConfig: TextMaskConfig = {
    mask: [],
    guide: true,
    placeholderChar: '_',
    pipe: undefined,
    keepCharPositions: false,
  }

  onChange = (_: any) => {}
  onTouched = () => {}

  private textMaskInputElement: any
  private inputElement!: HTMLInputElement

  /** Whether the user is creating a composition string (IME events). */
  private _composing = false

  constructor(
    private _renderer: Renderer2,
    private _elementRef: ElementRef,
    @Optional() @Inject(COMPOSITION_BUFFER_MODE)private _compositionMode: boolean
  ) {
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid()
    }
  }

  ngOnChanges(changes: SimpleChanges) {
    this._setupMask(true)
    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(this.inputElement.value)
    }
  }

  writeValue(value: any) {
    this._setupMask()

    // set the initial value for cases where the mask is disabled
    const normalizedValue = value == null ? '' : value
    this._renderer.setProperty(this.inputElement, 'value', normalizedValue)

    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(value)
    }
  }

  registerOnChange(fn: (_: any) => void): void { this.onChange = fn }
  registerOnTouched(fn: () => void): void { this.onTouched = fn }

  setDisabledState(isDisabled: boolean): void {
    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled)
  }

  
  _handleInput(value: any) {
    if (!this._compositionMode || (this._compositionMode && !this._composing)) {
      this._setupMask()

      if (this.textMaskInputElement !== undefined) {
        this.textMaskInputElement.update(value)
        
        // get the updated value
        value = this.inputElement.value
        this.onChange(value)
      }
    }
  }

  _setupMask(create = false) {
    if (!this.inputElement) {
      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
        // `textMask` directive is used directly on an input element
        this.inputElement = this._elementRef.nativeElement
      } else {
        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0]
      }
    }
    
    if (this.inputElement && create) {
      this.textMaskInputElement = createTextMaskInputElement(
        Object.assign({inputElement: this.inputElement}, this.textMaskConfig)
      )
    }
    
  }

  _compositionStart(): void { this._composing = true }

  _compositionEnd(value: any): void {
    this._composing = false
    this._compositionMode && this._handleInput(value)
  }
}

export { conformToMask } from './deps/text2mask/textMaskCore'

================
File: src/app/shared/pipes/hack-case.pipe.ts
================
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'hackCase'
})
export class HackCasePipe implements PipeTransform {

  transform(value: string | number, ...args: unknown[]): unknown {

    console.log(args);

    const leet: { [key: string]: number } = {
      'a': 4,
      'e': 3,
      'l': 1,
      't': 7,
      'z': 2,
      'o': 0
    };

    if (typeof value !== 'string')
      return "(not a string)";

    const chars = value.split('');

    let outStr = '';

    for (let i = 0; i < chars.length; i++) {

      const char = chars[i];

      if (leet[char] !== undefined) {
        outStr += leet[char];
      }
      else {
        outStr += char;
      }
    }

    return outStr;
  }

}

================
File: src/app/shared/pipes/highlight.pipe.ts
================
import { Pipe, PipeTransform } from '@angular/core';
import hljs from 'highlight.js';

@Pipe({
    name: 'highlight'
})
export class HighlightPipe implements PipeTransform {

    transform(value: string, ...args: unknown[]): unknown {
        return hljs.highlightAuto(value).value;
    }

}

================
File: src/app/shared/shared.module.ts
================
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';
import { RouterModule } from '@angular/router';
import { CdkDrag, CdkDropList } from '@angular/cdk/drag-drop';
import { ScrollingModule } from '@angular/cdk/scrolling';
import { BackButtonComponent } from './components/back-button/back-button.component';
import { BreadcrumbRouterComponent } from './components/breadcrumb-router/breadcrumb-router.component';
import { CopyPasterComponent } from './components/copy-paster/copy-paster.component';
import { InputComponent } from './components/input/input.component';
import { SearchRouterComponent } from './components/search-router/search-router.component';
import { TableComponent } from './components/table/table.component';
import { MonthpickerComponent } from './components/monthpicker/monthpicker.component';
import { AppChartComponent } from './components/chart.component';
import { ImageUploaderPreviewComponent } from './components/image-uploader-preview/image-uploader-preview.component';
import { LinearLoadingIndicatorComponent } from './components/linear-loading-indicator.component';
import { LetDirective } from './directives/ng-let';
import { MaskedInputDirective } from './directives/text2mask';
import { AppSortableHeader } from './directives/sortable-header';
import { HackCasePipe } from './pipes/hack-case.pipe';
import { HighlightPipe } from './pipes/highlight.pipe';
import { ToastsContainer } from './components/toasts-container/toasts-container.component';

@NgModule({
    declarations: [
        // Components
        BackButtonComponent,
        BreadcrumbRouterComponent,
        CopyPasterComponent,
        InputComponent,
        SearchRouterComponent,
        TableComponent,
        MonthpickerComponent,
        AppChartComponent,
        ImageUploaderPreviewComponent,
        LinearLoadingIndicatorComponent,
        ToastsContainer,
        // Directives
        LetDirective,
        MaskedInputDirective,
        AppSortableHeader,
        // Pipes
        HackCasePipe,
        HighlightPipe,
    ],
    imports: [
        CommonModule,
        HttpClientModule,
        RouterModule,
        FormsModule,
        ReactiveFormsModule,
        NgbModule,
        CdkDropList,
        CdkDrag,
        ScrollingModule,
    ],
    exports: [
        HttpClientModule,
        RouterModule,
        FormsModule,
        ReactiveFormsModule,
        NgbModule,
        CdkDropList,
        CdkDrag,
        ScrollingModule,
        // Components
        BackButtonComponent,
        BreadcrumbRouterComponent,
        CopyPasterComponent,
        InputComponent,
        SearchRouterComponent,
        TableComponent,
        MonthpickerComponent,
        AppChartComponent,
        ImageUploaderPreviewComponent,
        LinearLoadingIndicatorComponent,
        ToastsContainer,
        // Directives
        LetDirective,
        MaskedInputDirective,
        AppSortableHeader,
        // Pipes
        HackCasePipe,
        HighlightPipe,
    ]
})
export class SharedModule { }

================
File: src/app/syllogimous/components/card/card.component.html
================
<ng-template #content let-modal>
    <div class="modal-header">
        <h4 class="modal-title" id="modal-basic-title">Are you sure?</h4>
        <button class="btn-close" aria-label="Close" (click)="modal.dismiss()"></button>
    </div>
    <div class="modal-body">
        All your progresses will be deleted.<br>Are you sure you want to proceed with the reset?
    </div>
    <div class="modal-footer">
        <button class="btn btn-outline-secondary" (click)="modal.dismiss()">Cancel</button>
        <button class="btn btn-danger" (click)="modal.close()">Continue</button>
    </div>
</ng-template>

<div class="playcard card shadow">
    <div class="great-title d-none d-md-flex">
        <div>s</div>
        <div>y</div>
        <div>l</div>
        <div>l</div>
        <div>o</div>
        <div>g</div>
        <div>i</div>
        <div>m</div>
        <div>o</div>
        <div>u</div>
        <div>s</div>
        <div class="great-title-version">v4</div>
    </div>

    <div class="playcard-header card-header">
        <div class="playcard-toolbar">
            <div>
                <span
                    class="badge clickable fs-6"
                    [style.backgroundColor]="TIER_COLORS[sylSrv.tier].bgColor"
                    [style.color]="TIER_COLORS[sylSrv.tier].textColor"
                    [ngbTooltip]="tierTooltip"
			        [autoClose]="'outside'"
                    triggers="click"
                >
                    {{ sylSrv.tier }} <i class="bi bi-info-circle"></i>
                </span>
                <ng-template #tierTooltip>
                    <div class="text-start">
                        <div *ngFor="let tier of tiers">
                            <span class="badge" style="width: 80px;" [style.backgroundColor]="TIER_COLORS[tier].bgColor" [style.color]="TIER_COLORS[tier].textColor">{{ tier }}</span> {{ (TIER_SCORE_RANGES[tier].maxScore === Infinity) ? "above" : "" }} {{ (TIER_SCORE_RANGES[tier].minScore === -Infinity) ? "" : TIER_SCORE_RANGES[tier].minScore }} {{ (TIER_SCORE_RANGES[tier].maxScore === Infinity) ? "" : (TIER_SCORE_RANGES[tier].minScore === -Infinity) ? "below" : "-" }} {{ (TIER_SCORE_RANGES[tier].maxScore === Infinity) ? "" : (TIER_SCORE_RANGES[tier].maxScore + 1) }} pts
                        </div>
                    </div>
                </ng-template>
                <span class="text-muted ms-2">{{ sylSrv.score }} pts</span>
            </div>
            <div>
                <div ngbDropdown container="body">
                    <button class="btn" ngbDropdownToggle>More</button>
					<div ngbDropdownMenu>
                        <button ngbDropdownItem (click)="router.navigate([EnumScreens.Start])">Start Screen</button>
                        <button ngbDropdownItem (click)="router.navigate([EnumScreens.Intro])">Intro</button>
						<button ngbDropdownItem (click)="router.navigate([EnumScreens.Stats])">Stats</button>
						<button ngbDropdownItem (click)="router.navigate([EnumScreens.History])">History</button>
						<button ngbDropdownItem (click)="router.navigate([EnumScreens.Tutorials])">Tutorials</button>
						<button ngbDropdownItem (click)="resetGame(content)">Reset Game</button>
						<div class="dropdown-divider"></div>
                        <a ngbDropdownItem href="https://www.linkedin.com/in/f3d3r1c07r0774/" target="_blank">About the creator</a>
					</div>
				</div>
            </div>
        </div>
    </div>

    <div class="card-body p-0 overflow-hidden position-relative">
        <div class="playcard-body">
            <ng-content select="[body]"></ng-content>
        </div>
    </div>

    <div class="playcard-footer card-footer">
        <ng-content select="[footer]"></ng-content>
    </div>
</div>

================
File: src/app/syllogimous/components/card/card.component.scss
================
:host ::ng-deep {
    .playcard-header, 
    .playcard-footer {
        background: transparent;
        border: none;
    }

    .playcard-header:empty, 
    .playcard-footer:empty {
        padding: 0;
    }

    .playcard-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .subject {
        font-weight: 700;
    }

    .is-negated {
        color: #800000;
        font-weight: 700;
    }
}

.great-title {
    display: flex;
    align-items: end;
    justify-content: space-evenly;
    position: absolute;
    width: 100%;
    bottom: 100%;
    font-size: 3.25rem;
    line-height: 1;
    text-transform: uppercase;
    font-weight: 900;
    color: #0008;
}

.great-title-version {
    font-size: 1.75rem;
    text-transform: lowercase;
    margin-bottom: 0.25rem;
}

.playcard {
    width: min(36rem, 100vw);
    height: min(36rem, 100svh);
}

.playcard-body {
    display: grid;
    place-items: center;
    height: 100%;
    overflow: auto;
    padding: 1rem;
}

@media(max-width: 768px) {
    .playcard {
        width: 100vw;
        height: 100svh;
    }
}

================
File: src/app/syllogimous/components/card/card.component.ts
================
import { Component } from "@angular/core";
import { TIER_COLORS, TIER_SCORE_RANGES } from "../../constants/syllogimous.constants";
import { EnumScreens, EnumTiers } from "../../models/syllogimous.models";
import { SyllogimousService } from "../../services/syllogimous.service";
import { NgbModal } from "@ng-bootstrap/ng-bootstrap";
import { LS_DONT_SHOW, LS_HISTORY, LS_SCORE } from "../../constants/local-storage.constants";
import { EnumQuestionType } from "../../models/question.models";
import { Router } from "@angular/router";

@Component({
    selector: "app-card",
    styleUrls: ["./card.component.scss"],
    templateUrl: "./card.component.html"
})
export class CardComponent {
    TIER_COLORS = TIER_COLORS;
    TIER_SCORE_RANGES = TIER_SCORE_RANGES;
    EnumScreens = EnumScreens;
    tiers = Object.values(EnumTiers);
    Infinity = Infinity;

    constructor(
        public sylSrv: SyllogimousService,
        public router: Router,
        private modalService: NgbModal,
    ) {}

    async resetGame(content: any) {
        await this.modalService.open(content, { centered: true }).result;

        localStorage.removeItem(LS_SCORE);
        localStorage.removeItem(LS_HISTORY);

        for (const screen of Object.values(EnumScreens)) {
            localStorage.removeItem(LS_DONT_SHOW + screen);
        }

        for (const type of Object.values(EnumQuestionType)) {
            localStorage.removeItem(LS_DONT_SHOW + type);
        }

        location.reload();
    }
}

================
File: src/app/syllogimous/components/modal-level-change/modal-level-change.component.html
================
<div class="modal-body p-5 text-center">
    <h4>{{ title }}</h4>

    <div class="my-4" style="font-size: 1.15rem;">
        <div *ngFor="let content of contents">{{ content }}</div>
    </div>

    <button class="btn btn-primary" (click)="activeModal.close('Ok click')">Got It!</button>
</div>

================
File: src/app/syllogimous/components/modal-level-change/modal-level-change.component.ts
================
import { Component, Input } from '@angular/core';
import { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';

@Component({
    selector: 'app-modal-level-change',
    templateUrl: './modal-level-change.component.html',
    styleUrls: ['./modal-level-change.component.css']
})
export class ModalLevelChangeComponent {
    @Input("title") title?: string;
    @Input("content") content?: string;
    contents: string[] = [];

    constructor(
        public activeModal: NgbActiveModal
    ) { }

    ngOnInit() {
        if (this.content) {
            this.contents = this.content.split("\n");
        }
    }
}

================
File: src/app/syllogimous/constants/engine.constants.ts
================
import { getDirectionString } from "../utils/engine.utils";

export const STRINGS = [
    "QAW",
    "QAR",
    "QAT",
    "QAP",
    "QAS",
    "QAD",
    "QAF",
    "QAG",
    "QAK",
    "QAL",
    "QAZ",
    "QAX",
    "QAC",
    "QAV",
    "QAB",
    "QAN",
    "QAM",
    "QEW",
    "QER",
    "QET",
    "QEP",
    "QES",
    "QED",
    "QEF",
    "QEG",
    "QEK",
    "QEL",
    "QEZ",
    "QEX",
    "QEC",
    "QEV",
    "QEB",
    "QEN",
    "QEM",
    "QIW",
    "QIR",
    "QIT",
    "QIP",
    "QIS",
    "QID",
    "QIF",
    "QIG",
    "QIK",
    "QIL",
    "QIZ",
    "QIX",
    "QIC",
    "QIV",
    "QIB",
    "QIN",
    "QIM",
    "QOW",
    "QOR",
    "QOT",
    "QOP",
    "QOS",
    "QOD",
    "QOF",
    "QOG",
    "QOK",
    "QOL",
    "QOZ",
    "QOX",
    "QOC",
    "QOV",
    "QOB",
    "QON",
    "QOM",
    "QUW",
    "QUR",
    "QUT",
    "QUP",
    "QUS",
    "QUD",
    "QUF",
    "QUG",
    "QUK",
    "QUL",
    "QUZ",
    "QUX",
    "QUC",
    "QUV",
    "QUB",
    "QUN",
    "QUM",
    "WAQ",
    "WAR",
    "WAT",
    "WAP",
    "WAS",
    "WAD",
    "WAF",
    "WAG",
    "WAK",
    "WAL",
    "WAZ",
    "WAX",
    "WAC",
    "WAV",
    "WAB",
    "WAN",
    "WAM",
    "WEQ",
    "WER",
    "WET",
    "WEP",
    "WES",
    "WED",
    "WEF",
    "WEG",
    "WEK",
    "WEL",
    "WEZ",
    "WEX",
    "WEC",
    "WEV",
    "WEB",
    "WEN",
    "WEM",
    "WIQ",
    "WIR",
    "WIT",
    "WIP",
    "WIS",
    "WID",
    "WIF",
    "WIG",
    "WIK",
    "WIL",
    "WIZ",
    "WIX",
    "WIC",
    "WIV",
    "WIB",
    "WIN",
    "WIM",
    "WOQ",
    "WOR",
    "WOT",
    "WOP",
    "WOS",
    "WOD",
    "WOF",
    "WOG",
    "WOK",
    "WOL",
    "WOZ",
    "WOX",
    "WOC",
    "WOV",
    "WOB",
    "WON",
    "WOM",
    "WUQ",
    "WUR",
    "WUT",
    "WUP",
    "WUS",
    "WUD",
    "WUF",
    "WUG",
    "WUK",
    "WUL",
    "WUZ",
    "WUX",
    "WUC",
    "WUV",
    "WUB",
    "WUN",
    "WUM",
    "RAQ",
    "RAW",
    "RAT",
    "RAP",
    "RAS",
    "RAD",
    "RAF",
    "RAG",
    "RAK",
    "RAL",
    "RAZ",
    "RAX",
    "RAC",
    "RAV",
    "RAB",
    "RAN",
    "RAM",
    "REQ",
    "REW",
    "RET",
    "REP",
    "RES",
    "RED",
    "REF",
    "REG",
    "REK",
    "REL",
    "REZ",
    "REX",
    "REC",
    "REV",
    "REB",
    "REN",
    "REM",
    "RIQ",
    "RIW",
    "RIT",
    "RIP",
    "RIS",
    "RID",
    "RIF",
    "RIG",
    "RIK",
    "RIL",
    "RIZ",
    "RIX",
    "RIC",
    "RIV",
    "RIB",
    "RIN",
    "RIM",
    "ROQ",
    "ROW",
    "ROT",
    "ROP",
    "ROS",
    "ROD",
    "ROF",
    "ROG",
    "ROK",
    "ROL",
    "ROZ",
    "ROX",
    "ROC",
    "ROV",
    "ROB",
    "RON",
    "ROM",
    "RUQ",
    "RUW",
    "RUT",
    "RUP",
    "RUS",
    "RUD",
    "RUF",
    "RUG",
    "RUK",
    "RUL",
    "RUZ",
    "RUX",
    "RUC",
    "RUV",
    "RUB",
    "RUN",
    "RUM",
    "TAQ",
    "TAW",
    "TAR",
    "TAP",
    "TAS",
    "TAD",
    "TAF",
    "TAG",
    "TAK",
    "TAL",
    "TAZ",
    "TAX",
    "TAC",
    "TAV",
    "TAB",
    "TAN",
    "TAM",
    "TEQ",
    "TEW",
    "TER",
    "TEP",
    "TES",
    "TED",
    "TEF",
    "TEG",
    "TEK",
    "TEL",
    "TEZ",
    "TEX",
    "TEC",
    "TEV",
    "TEB",
    "TEN",
    "TEM",
    "TIQ",
    "TIW",
    "TIR",
    "TIP",
    "TIS",
    "TID",
    "TIF",
    "TIG",
    "TIK",
    "TIL",
    "TIZ",
    "TIX",
    "TIC",
    "TIV",
    "TIB",
    "TIN",
    "TIM",
    "TOQ",
    "TOW",
    "TOR",
    "TOP",
    "TOS",
    "TOD",
    "TOF",
    "TOG",
    "TOK",
    "TOL",
    "TOZ",
    "TOX",
    "TOC",
    "TOV",
    "TOB",
    "TON",
    "TOM",
    "TUQ",
    "TUW",
    "TUR",
    "TUP",
    "TUS",
    "TUD",
    "TUF",
    "TUG",
    "TUK",
    "TUL",
    "TUZ",
    "TUX",
    "TUC",
    "TUV",
    "TUB",
    "TUN",
    "TUM",
    "PAQ",
    "PAW",
    "PAR",
    "PAT",
    "PAS",
    "PAD",
    "PAF",
    "PAG",
    "PAK",
    "PAL",
    "PAZ",
    "PAX",
    "PAC",
    "PAV",
    "PAB",
    "PAN",
    "PAM",
    "PEQ",
    "PEW",
    "PER",
    "PET",
    "PES",
    "PED",
    "PEF",
    "PEG",
    "PEK",
    "PEL",
    "PEZ",
    "PEX",
    "PEC",
    "PEV",
    "PEB",
    "PEN",
    "PEM",
    "PIQ",
    "PIW",
    "PIR",
    "PIT",
    "PIS",
    "PID",
    "PIF",
    "PIG",
    "PIK",
    "PIL",
    "PIZ",
    "PIX",
    "PIC",
    "PIV",
    "PIB",
    "PIN",
    "PIM",
    "POQ",
    "POW",
    "POR",
    "POT",
    "POS",
    "POD",
    "POF",
    "POG",
    "POK",
    "POL",
    "POZ",
    "POX",
    "POC",
    "POV",
    "POB",
    "PON",
    "POM",
    "PUQ",
    "PUW",
    "PUR",
    "PUT",
    "PUS",
    "PUD",
    "PUF",
    "PUG",
    "PUK",
    "PUL",
    "PUZ",
    "PUX",
    "PUC",
    "PUV",
    "PUB",
    "PUN",
    "PUM",
    "SAQ",
    "SAW",
    "SAR",
    "SAT",
    "SAP",
    "SAD",
    "SAF",
    "SAG",
    "SAK",
    "SAL",
    "SAZ",
    "SAX",
    "SAC",
    "SAV",
    "SAB",
    "SAN",
    "SAM",
    "SEQ",
    "SEW",
    "SER",
    "SET",
    "SEP",
    "SED",
    "SEF",
    "SEG",
    "SEK",
    "SEL",
    "SEZ",
    "SEX",
    "SEC",
    "SEV",
    "SEB",
    "SEN",
    "SEM",
    "SIQ",
    "SIW",
    "SIR",
    "SIT",
    "SIP",
    "SID",
    "SIF",
    "SIG",
    "SIK",
    "SIL",
    "SIZ",
    "SIX",
    "SIC",
    "SIV",
    "SIB",
    "SIN",
    "SIM",
    "SOQ",
    "SOW",
    "SOR",
    "SOT",
    "SOP",
    "SOD",
    "SOF",
    "SOG",
    "SOK",
    "SOL",
    "SOZ",
    "SOX",
    "SOC",
    "SOV",
    "SOB",
    "SON",
    "SOM",
    "SUQ",
    "SUW",
    "SUR",
    "SUT",
    "SUP",
    "SUD",
    "SUF",
    "SUG",
    "SUK",
    "SUL",
    "SUZ",
    "SUX",
    "SUC",
    "SUV",
    "SUB",
    "SUN",
    "SUM",
    "DAQ",
    "DAW",
    "DAR",
    "DAT",
    "DAP",
    "DAS",
    "DAF",
    "DAG",
    "DAK",
    "DAL",
    "DAZ",
    "DAX",
    "DAC",
    "DAV",
    "DAB",
    "DAN",
    "DAM",
    "DEQ",
    "DEW",
    "DER",
    "DET",
    "DEP",
    "DES",
    "DEF",
    "DEG",
    "DEK",
    "DEL",
    "DEZ",
    "DEX",
    "DEC",
    "DEV",
    "DEB",
    "DEN",
    "DEM",
    "DIQ",
    "DIW",
    "DIR",
    "DIT",
    "DIP",
    "DIS",
    "DIF",
    "DIG",
    "DIK",
    "DIL",
    "DIZ",
    "DIX",
    "DIC",
    "DIV",
    "DIB",
    "DIN",
    "DIM",
    "DOQ",
    "DOW",
    "DOR",
    "DOT",
    "DOP",
    "DOS",
    "DOF",
    "DOG",
    "DOK",
    "DOL",
    "DOZ",
    "DOX",
    "DOC",
    "DOV",
    "DOB",
    "DON",
    "DOM",
    "DUQ",
    "DUW",
    "DUR",
    "DUT",
    "DUP",
    "DUS",
    "DUF",
    "DUG",
    "DUK",
    "DUL",
    "DUZ",
    "DUX",
    "DUC",
    "DUV",
    "DUB",
    "DUN",
    "DUM",
    "FAQ",
    "FAW",
    "FAR",
    "FAT",
    "FAP",
    "FAS",
    "FAD",
    "FAG",
    "FAK",
    "FAL",
    "FAZ",
    "FAX",
    "FAC",
    "FAV",
    "FAB",
    "FAN",
    "FAM",
    "FEQ",
    "FEW",
    "FER",
    "FET",
    "FEP",
    "FES",
    "FED",
    "FEG",
    "FEK",
    "FEL",
    "FEZ",
    "FEX",
    "FEC",
    "FEV",
    "FEB",
    "FEN",
    "FEM",
    "FIQ",
    "FIW",
    "FIR",
    "FIT",
    "FIP",
    "FIS",
    "FID",
    "FIG",
    "FIK",
    "FIL",
    "FIZ",
    "FIX",
    "FIC",
    "FIV",
    "FIB",
    "FIN",
    "FIM",
    "FOQ",
    "FOW",
    "FOR",
    "FOT",
    "FOP",
    "FOS",
    "FOD",
    "FOG",
    "FOK",
    "FOL",
    "FOZ",
    "FOX",
    "FOC",
    "FOV",
    "FOB",
    "FON",
    "FOM",
    "FUQ",
    "FUW",
    "FUR",
    "FUT",
    "FUP",
    "FUS",
    "FUD",
    "FUG",
    "FUK",
    "FUL",
    "FUZ",
    "FUX",
    "FUC",
    "FUV",
    "FUB",
    "FUN",
    "FUM",
    "GAQ",
    "GAW",
    "GAR",
    "GAT",
    "GAP",
    "GAS",
    "GAD",
    "GAF",
    "GAK",
    "GAL",
    "GAZ",
    "GAX",
    "GAC",
    "GAV",
    "GAB",
    "GAN",
    "GAM",
    "GEQ",
    "GEW",
    "GER",
    "GET",
    "GEP",
    "GES",
    "GED",
    "GEF",
    "GEK",
    "GEL",
    "GEZ",
    "GEX",
    "GEC",
    "GEV",
    "GEB",
    "GEN",
    "GEM",
    "GIQ",
    "GIW",
    "GIR",
    "GIT",
    "GIP",
    "GIS",
    "GID",
    "GIF",
    "GIK",
    "GIL",
    "GIZ",
    "GIX",
    "GIC",
    "GIV",
    "GIB",
    "GIN",
    "GIM",
    "GOQ",
    "GOW",
    "GOR",
    "GOT",
    "GOP",
    "GOS",
    "GOD",
    "GOF",
    "GOK",
    "GOL",
    "GOZ",
    "GOX",
    "GOC",
    "GOV",
    "GOB",
    "GON",
    "GOM",
    "GUQ",
    "GUW",
    "GUR",
    "GUT",
    "GUP",
    "GUS",
    "GUD",
    "GUF",
    "GUK",
    "GUL",
    "GUZ",
    "GUX",
    "GUC",
    "GUV",
    "GUB",
    "GUN",
    "GUM",
    "KAQ",
    "KAW",
    "KAR",
    "KAT",
    "KAP",
    "KAS",
    "KAD",
    "KAF",
    "KAG",
    "KAL",
    "KAZ",
    "KAX",
    "KAC",
    "KAV",
    "KAB",
    "KAN",
    "KAM",
    "KEQ",
    "KEW",
    "KER",
    "KET",
    "KEP",
    "KES",
    "KED",
    "KEF",
    "KEG",
    "KEL",
    "KEZ",
    "KEX",
    "KEC",
    "KEV",
    "KEB",
    "KEN",
    "KEM",
    "KIQ",
    "KIW",
    "KIR",
    "KIT",
    "KIP",
    "KIS",
    "KID",
    "KIF",
    "KIG",
    "KIL",
    "KIZ",
    "KIX",
    "KIC",
    "KIV",
    "KIB",
    "KIN",
    "KIM",
    "KOQ",
    "KOW",
    "KOR",
    "KOT",
    "KOP",
    "KOS",
    "KOD",
    "KOF",
    "KOG",
    "KOL",
    "KOZ",
    "KOX",
    "KOC",
    "KOV",
    "KOB",
    "KON",
    "KOM",
    "KUQ",
    "KUW",
    "KUR",
    "KUT",
    "KUP",
    "KUS",
    "KUD",
    "KUF",
    "KUG",
    "KUL",
    "KUZ",
    "KUX",
    "KUC",
    "KUV",
    "KUB",
    "KUN",
    "KUM",
    "LAQ",
    "LAW",
    "LAR",
    "LAT",
    "LAP",
    "LAS",
    "LAD",
    "LAF",
    "LAG",
    "LAK",
    "LAZ",
    "LAX",
    "LAC",
    "LAV",
    "LAB",
    "LAN",
    "LAM",
    "LEQ",
    "LEW",
    "LER",
    "LET",
    "LEP",
    "LES",
    "LED",
    "LEF",
    "LEG",
    "LEK",
    "LEZ",
    "LEX",
    "LEC",
    "LEV",
    "LEB",
    "LEN",
    "LEM",
    "LIQ",
    "LIW",
    "LIR",
    "LIT",
    "LIP",
    "LIS",
    "LID",
    "LIF",
    "LIG",
    "LIK",
    "LIZ",
    "LIX",
    "LIC",
    "LIV",
    "LIB",
    "LIN",
    "LIM",
    "LOQ",
    "LOW",
    "LOR",
    "LOT",
    "LOP",
    "LOS",
    "LOD",
    "LOF",
    "LOG",
    "LOK",
    "LOZ",
    "LOX",
    "LOC",
    "LOV",
    "LOB",
    "LON",
    "LOM",
    "LUQ",
    "LUW",
    "LUR",
    "LUT",
    "LUP",
    "LUS",
    "LUD",
    "LUF",
    "LUG",
    "LUK",
    "LUZ",
    "LUX",
    "LUC",
    "LUV",
    "LUB",
    "LUN",
    "LUM",
    "ZAQ",
    "ZAW",
    "ZAR",
    "ZAT",
    "ZAP",
    "ZAS",
    "ZAD",
    "ZAF",
    "ZAG",
    "ZAK",
    "ZAL",
    "ZAX",
    "ZAC",
    "ZAV",
    "ZAB",
    "ZAN",
    "ZAM",
    "ZEQ",
    "ZEW",
    "ZER",
    "ZET",
    "ZEP",
    "ZES",
    "ZED",
    "ZEF",
    "ZEG",
    "ZEK",
    "ZEL",
    "ZEX",
    "ZEC",
    "ZEV",
    "ZEB",
    "ZEN",
    "ZEM",
    "ZIQ",
    "ZIW",
    "ZIR",
    "ZIT",
    "ZIP",
    "ZIS",
    "ZID",
    "ZIF",
    "ZIG",
    "ZIK",
    "ZIL",
    "ZIX",
    "ZIC",
    "ZIV",
    "ZIB",
    "ZIN",
    "ZIM",
    "ZOQ",
    "ZOW",
    "ZOR",
    "ZOT",
    "ZOP",
    "ZOS",
    "ZOD",
    "ZOF",
    "ZOG",
    "ZOK",
    "ZOL",
    "ZOX",
    "ZOC",
    "ZOV",
    "ZOB",
    "ZON",
    "ZOM",
    "ZUQ",
    "ZUW",
    "ZUR",
    "ZUT",
    "ZUP",
    "ZUS",
    "ZUD",
    "ZUF",
    "ZUG",
    "ZUK",
    "ZUL",
    "ZUX",
    "ZUC",
    "ZUV",
    "ZUB",
    "ZUN",
    "ZUM",
    "XAQ",
    "XAW",
    "XAR",
    "XAT",
    "XAP",
    "XAS",
    "XAD",
    "XAF",
    "XAG",
    "XAK",
    "XAL",
    "XAZ",
    "XAC",
    "XAV",
    "XAB",
    "XAN",
    "XAM",
    "XEQ",
    "XEW",
    "XER",
    "XET",
    "XEP",
    "XES",
    "XED",
    "XEF",
    "XEG",
    "XEK",
    "XEL",
    "XEZ",
    "XEC",
    "XEV",
    "XEB",
    "XEN",
    "XEM",
    "XIQ",
    "XIW",
    "XIR",
    "XIT",
    "XIP",
    "XIS",
    "XID",
    "XIF",
    "XIG",
    "XIK",
    "XIL",
    "XIZ",
    "XIC",
    "XIV",
    "XIB",
    "XIN",
    "XIM",
    "XOQ",
    "XOW",
    "XOR",
    "XOT",
    "XOP",
    "XOS",
    "XOD",
    "XOF",
    "XOG",
    "XOK",
    "XOL",
    "XOZ",
    "XOC",
    "XOV",
    "XOB",
    "XON",
    "XOM",
    "XUQ",
    "XUW",
    "XUR",
    "XUT",
    "XUP",
    "XUS",
    "XUD",
    "XUF",
    "XUG",
    "XUK",
    "XUL",
    "XUZ",
    "XUC",
    "XUV",
    "XUB",
    "XUN",
    "XUM",
    "CAQ",
    "CAW",
    "CAR",
    "CAT",
    "CAP",
    "CAS",
    "CAD",
    "CAF",
    "CAG",
    "CAK",
    "CAL",
    "CAZ",
    "CAX",
    "CAV",
    "CAB",
    "CAN",
    "CAM",
    "CEQ",
    "CEW",
    "CER",
    "CET",
    "CEP",
    "CES",
    "CED",
    "CEF",
    "CEG",
    "CEK",
    "CEL",
    "CEZ",
    "CEX",
    "CEV",
    "CEB",
    "CEN",
    "CEM",
    "CIQ",
    "CIW",
    "CIR",
    "CIT",
    "CIP",
    "CIS",
    "CID",
    "CIF",
    "CIG",
    "CIK",
    "CIL",
    "CIZ",
    "CIX",
    "CIV",
    "CIB",
    "CIN",
    "CIM",
    "COQ",
    "COW",
    "COR",
    "COT",
    "COP",
    "COS",
    "COD",
    "COF",
    "COG",
    "COK",
    "COL",
    "COZ",
    "COX",
    "COV",
    "COB",
    "CON",
    "COM",
    "CUQ",
    "CUW",
    "CUR",
    "CUT",
    "CUP",
    "CUS",
    "CUD",
    "CUF",
    "CUG",
    "CUK",
    "CUL",
    "CUZ",
    "CUX",
    "CUV",
    "CUB",
    "CUN",
    "CUM",
    "VAQ",
    "VAW",
    "VAR",
    "VAT",
    "VAP",
    "VAS",
    "VAD",
    "VAF",
    "VAG",
    "VAK",
    "VAL",
    "VAZ",
    "VAX",
    "VAC",
    "VAB",
    "VAN",
    "VAM",
    "VEQ",
    "VEW",
    "VER",
    "VET",
    "VEP",
    "VES",
    "VED",
    "VEF",
    "VEG",
    "VEK",
    "VEL",
    "VEZ",
    "VEX",
    "VEC",
    "VEB",
    "VEN",
    "VEM",
    "VIQ",
    "VIW",
    "VIR",
    "VIT",
    "VIP",
    "VIS",
    "VID",
    "VIF",
    "VIG",
    "VIK",
    "VIL",
    "VIZ",
    "VIX",
    "VIC",
    "VIB",
    "VIN",
    "VIM",
    "VOQ",
    "VOW",
    "VOR",
    "VOT",
    "VOP",
    "VOS",
    "VOD",
    "VOF",
    "VOG",
    "VOK",
    "VOL",
    "VOZ",
    "VOX",
    "VOC",
    "VOB",
    "VON",
    "VOM",
    "VUQ",
    "VUW",
    "VUR",
    "VUT",
    "VUP",
    "VUS",
    "VUD",
    "VUF",
    "VUG",
    "VUK",
    "VUL",
    "VUZ",
    "VUX",
    "VUC",
    "VUB",
    "VUN",
    "VUM",
    "BAQ",
    "BAW",
    "BAR",
    "BAT",
    "BAP",
    "BAS",
    "BAD",
    "BAF",
    "BAG",
    "BAK",
    "BAL",
    "BAZ",
    "BAX",
    "BAC",
    "BAV",
    "BAN",
    "BAM",
    "BEQ",
    "BEW",
    "BER",
    "BET",
    "BEP",
    "BES",
    "BED",
    "BEF",
    "BEG",
    "BEK",
    "BEL",
    "BEZ",
    "BEX",
    "BEC",
    "BEV",
    "BEN",
    "BEM",
    "BIQ",
    "BIW",
    "BIR",
    "BIT",
    "BIP",
    "BIS",
    "BID",
    "BIF",
    "BIG",
    "BIK",
    "BIL",
    "BIZ",
    "BIX",
    "BIC",
    "BIV",
    "BIN",
    "BIM",
    "BOQ",
    "BOW",
    "BOR",
    "BOT",
    "BOP",
    "BOS",
    "BOD",
    "BOF",
    "BOG",
    "BOK",
    "BOL",
    "BOZ",
    "BOX",
    "BOC",
    "BOV",
    "BON",
    "BOM",
    "BUQ",
    "BUW",
    "BUR",
    "BUT",
    "BUP",
    "BUS",
    "BUD",
    "BUF",
    "BUG",
    "BUK",
    "BUL",
    "BUZ",
    "BUX",
    "BUC",
    "BUV",
    "BUN",
    "BUM",
    "NAQ",
    "NAW",
    "NAR",
    "NAT",
    "NAP",
    "NAS",
    "NAD",
    "NAF",
    "NAG",
    "NAK",
    "NAL",
    "NAZ",
    "NAX",
    "NAC",
    "NAV",
    "NAB",
    "NAM",
    "NEQ",
    "NEW",
    "NER",
    "NET",
    "NEP",
    "NES",
    "NED",
    "NEF",
    "NEG",
    "NEK",
    "NEL",
    "NEZ",
    "NEX",
    "NEC",
    "NEV",
    "NEB",
    "NEM",
    "NIQ",
    "NIW",
    "NIR",
    "NIT",
    "NIP",
    "NIS",
    "NID",
    "NIF",
    "NIG",
    "NIK",
    "NIL",
    "NIZ",
    "NIX",
    "NIC",
    "NIV",
    "NIB",
    "NIM",
    "NOQ",
    "NOW",
    "NOR",
    "NOT",
    "NOP",
    "NOS",
    "NOD",
    "NOF",
    "NOG",
    "NOK",
    "NOL",
    "NOZ",
    "NOX",
    "NOC",
    "NOV",
    "NOB",
    "NOM",
    "NUQ",
    "NUW",
    "NUR",
    "NUT",
    "NUP",
    "NUS",
    "NUD",
    "NUF",
    "NUG",
    "NUK",
    "NUL",
    "NUZ",
    "NUX",
    "NUC",
    "NUV",
    "NUB",
    "NUM",
    "MAQ",
    "MAW",
    "MAR",
    "MAT",
    "MAP",
    "MAS",
    "MAD",
    "MAF",
    "MAG",
    "MAK",
    "MAL",
    "MAZ",
    "MAX",
    "MAC",
    "MAV",
    "MAB",
    "MAN",
    "MEQ",
    "MEW",
    "MER",
    "MET",
    "MEP",
    "MES",
    "MED",
    "MEF",
    "MEG",
    "MEK",
    "MEL",
    "MEZ",
    "MEX",
    "MEC",
    "MEV",
    "MEB",
    "MEN",
    "MIQ",
    "MIW",
    "MIR",
    "MIT",
    "MIP",
    "MIS",
    "MID",
    "MIF",
    "MIG",
    "MIK",
    "MIL",
    "MIZ",
    "MIX",
    "MIC",
    "MIV",
    "MIB",
    "MIN",
    "MOQ",
    "MOW",
    "MOR",
    "MOT",
    "MOP",
    "MOS",
    "MOD",
    "MOF",
    "MOG",
    "MOK",
    "MOL",
    "MOZ",
    "MOX",
    "MOC",
    "MOV",
    "MOB",
    "MON",
    "MUQ",
    "MUW",
    "MUR",
    "MUT",
    "MUP",
    "MUS",
    "MUD",
    "MUF",
    "MUG",
    "MUK",
    "MUL",
    "MUZ",
    "MUX",
    "MUC",
    "MUV",
    "MUB",
    "MUN"
];

export const NOUNS = [
    "Ankle",
    "Ant",
    "Antlers",
    "Apartment",
    "Apple",
    "Apricot",
    "Architect",
    "Armchair",
    "Arrow",
    "Aunt",
    "Baby",
    "Back",
    "Backyard",
    "Bag",
    "Bakery",
    "Ball",
    "Balloon",
    "Bank",
    "Bar",
    "Barbie",
    "Basket",
    "Bat",
    "Beans",
    "Bear",
    "Bed",
    "Bell",
    "Belt",
    "Bermudas",
    "Bicycle",
    "Bike",
    "Bikini",
    "Bill",
    "Bird",
    "Biscuit",
    "Black",
    "Blade",
    "Blazer",
    "Blender",
    "Board",
    "Boat",
    "Bones",
    "Book",
    "Bookcase",
    "Bookstore",
    "Boots",
    "Bow",
    "Box",
    "Boxer",
    "Boy",
    "Brain",
    "Brass",
    "Bread",
    "Bridge",
    "Brother",
    "Brush",
    "Bucket",
    "Buckles",
    "Buffalo",
    "Bulb",
    "Bus",
    "Butter",
    "Buttons",
    "Cabin",
    "Cabinet",
    "Cable",
    "Cafe",
    "Camera",
    "Candy",
    "Cane",
    "Canoe",
    "Cap",
    "Car",
    "Taxi",
    "Cardigan",
    "Carpet",
    "Cashier",
    "Casino",
    "Castle",
    "Cat",
    "Cave",
    "Cello",
    "Cement",
    "Chair",
    "Cheeks",
    "Cheese",
    "Chest",
    "Chicken",
    "Children",
    "Chips",
    "Chocolate",
    "Choker",
    "Church",
    "Cinema",
    "City",
    "Clip",
    "Clock",
    "Clothes",
    "Cloud",
    "Coconut",
    "Coffee",
    "Coin",
    "Color",
    "Computer",
    "Cooker",
    "Cookware",
    "Corn",
    "Costume",
    "Couch",
    "Country",
    "Cow",
    "Cravat",
    "Credenza",
    "Crib",
    "Crow",
    "Cup",
    "Cucumber",
    "Cupboard",
    "Currency",
    "Cylinder",
    "Dates",
    "Daughter",
    "Deer",
    "Dentist",
    "Designer",
    "Desk",
    "Desktop",
    "Detective",
    "Doctor",
    "Dog",
    "Dolphin",
    "Donkey",
    "Dress",
    "Dresser",
    "Drink",
    "Drum",
    "Dust",
    "Eagle",
    "Earrings",
    "Ears",
    "Earth",
    "Egg",
    "Elephant",
    "Eraser",
    "Estate",
    "Eyes",
    "Factory",
    "Fan",
    "Farm",
    "Father",
    "Film",
    "Finger",
    "Fire",
    "Fish",
    "Flag",
    "Flower",
    "Food",
    "Foot",
    "Forest",
    "Fork",
    "Fox",
    "Freezer",
    "Fridge",
    "Frog",
    "Fruit",
    "Gadgets",
    "Galaxy",
    "Garage",
    "Garden",
    "Garlic",
    "Gas",
    "Gel",
    "Gift",
    "Ginger",
    "Giraffe",
    "Girl",
    "Glass",
    "Gloves",
    "Goat",
    "Governor",
    "Grains",
    "Grapes",
    "Guest",
    "Guitar",
    "Hair",
    "Hamburger",
    "Hammer",
    "Hand",
    "Hat",
    "Head",
    "Heart",
    "Heels",
    "Herbs",
    "Hockey",
    "Horn",
    "Horse",
    "Hospital",
    "Host",
    "Hostel",
    "Hotel",
    "House",
    "Ice",
    "Icecream",
    "Iron",
    "Jacket",
    "Jaw",
    "Jewelry",
    "Judge",
    "Jug",
    "Juicer",
    "Jumper",
    "Kangaroo",
    "Key",
    "Keyboard",
    "Kid",
    "Kit",
    "Kite",
    "Knife",
    "Koala",
    "Lamb",
    "Lamp",
    "Laptop",
    "Lawyer",
    "Leather",
    "Leaves",
    "Leg",
    "Leggings",
    "Lemon",
    "Library",
    "Lift",
    "Light",
    "Lighter",
    "Lion",
    "Lips",
    "Lock",
    "London",
    "Luggage",
    "Lung",
    "Mall",
    "Man",
    "Mango",
    "Market",
    "Mars",
    "Medicine",
    "Milk",
    "Mirror",
    "Mobile",
    "Model",
    "Monitor",
    "Monkey",
    "Moon",
    "Moonlight",
    "Mother",
    "Motor",
    "Mountain",
    "Mouse",
    "Mouth",
    "Museum",
    "Music",
    "Musician",
    "Neck",
    "Necklace",
    "Newspaper",
    "Noise",
    "Noodles",
    "Nose",
    "Notebook",
    "Nurse",
    "Ocean",
    "Oil",
    "Onion",
    "Orange",
    "Ostrich",
    "Oven",
    "Owl",
    "Pad",
    "Pagoda",
    "Paint",
    "Painter",
    "Palm",
    "Pancake",
    "Panda",
    "Panther",
    "Pants",
    "Paper",
    "Parfume",
    "Park",
    "Parrot",
    "Pasta",
    "Peacock",
    "Peanut",
    "Pen",
    "Pencil",
    "Perfume",
    "Pharmacy",
    "Phone",
    "Physician",
    "Piano",
    "Pig",
    "Pigeon",
    "Pipe",
    "Pizza",
    "Plane",
    "Planet",
    "Plant",
    "Plastic",
    "Plates",
    "Police",
    "Popcorn",
    "Potato",
    "Pouch",
    "Professor",
    "Pumpkin",
    "Pyramid",
    "Rabbit",
    "Radio",
    "Rainbow",
    "Razor",
    "Remote",
    "Ribs",
    "Rice",
    "Ring",
    "River",
    "Road",
    "Rope",
    "Rubber",
    "Salt",
    "Sand",
    "Sandals",
    "Sandwich",
    "Saw",
    "Saxophone",
    "Scale",
    "School",
    "Scissors",
    "Sea",
    "Senator",
    "Shampoo",
    "Shark",
    "Sheep",
    "Ship",
    "Shirt",
    "Shoes",
    "Shop",
    "Shorts",
    "Shoulder",
    "Shower",
    "Shrimp",
    "Singer",
    "Sink",
    "Sister",
    "Skirt",
    "Sky",
    "Slippers",
    "Smile",
    "Smoke",
    "Snowman",
    "Soap",
    "Socks",
    "Sofa",
    "Soil",
    "Son",
    "Soup",
    "Spaghetti",
    "Sparrow",
    "Spider",
    "Spoon",
    "Stadium",
    "Stair",
    "Star",
    "Station",
    "Stem",
    "Stomach",
    "Stove",
    "Street",
    "Sugar",
    "Suit",
    "Suitcase",
    "Sun",
    "Surgeon",
    "Swan",
    "Sweater",
    "Sweet",
    "Table",
    "Tablet",
    "Tail",
    "Tap",
    "Taxi",
    "Tea",
    "Teacher",
    "Teen",
    "Teeth",
    "Telephone",
    "Temple",
    "Tennis",
    "Theater",
    "Thread",
    "Tie",
    "Tiger",
    "Tissue",
    "Toes",
    "Tomato",
    "Tongue",
    "Tools",
    "Towel",
    "Town",
    "Toy",
    "Train",
    "Tree",
    "Trousers",
    "Truck",
    "Tunnel",
    "Turkey",
    "Turtle",
    "Umbrella",
    "Uncle",
    "Underwear",
    "Van",
    "Vase",
    "Vegetable",
    "Vehicle",
    "Vest",
    "Villa",
    "Village",
    "Violin",
    "Voice",
    "Waist",
    "Waiter",
    "Wall",
    "Wallet",
    "Watch",
    "Water",
    "Whale",
    "Wheat",
    "Whisker",
    "Window",
    "Wings",
    "Winter",
    "Wire",
    "Wolf",
    "Woman",
    "Wood",
    "Wound",
    "Wrist",
    "Xylophone",
    "Zebra",
    "Zoo"
];

export const VALID_RULES = [
    "0001",
    "1011",
    "0221",
    "1231",
    "0021",
    "1031",
    "0112",
    "1012",
    "1232",
    "0332",
    "0132",
    "1032",
    "0223",
    "2023",
    "3033",
    "1233",
    "0023",
    "1033",
    "0114",
    "2024",
    "1234",
    "0134",
    "1034",
    "0024"
];

export const FORMS = [
    [
        'All <span class="subject">$</span> is <span class="subject">$</span>',
        'No <span class="subject">$</span> is <span class="subject">$</span>',
        'Some <span class="subject">$</span> is <span class="subject">$</span>',
        'Some <span class="subject">$</span> is not <span class="subject">$</span>'
    ],
    [
        '<span class="is-negated">No</span> <span class="subject">$</span> is <span class="subject">$</span>',
        '<span class="is-negated">All</span> <span class="subject">$</span> is <span class="subject">$</span>',
        'Some <span class="subject">$</span> <span class="is-negated">is not</span> <span class="subject">$</span>',
        'Some <span class="subject">$</span> <span class="is-negated">is</span> <span class="subject">$</span>'
    ],
];

export const DIRECTION_NAMES = [
    null,
    "North",
    "North-East",
    "East",
    "South-East",
    "South",
    "South-West",
    "West",
    "North-West"
];

export const DIRECTION_NAMES_INVERSE = {
    "North": "South",
    "East":  "West",
    "South": "North",
    "West":  "East",
    "North-East": "South-West",
    "South-East": "North-West",
    "South-West": "North-East",
    "North-West": "South-East"
};

export const DIRECTION_COORDS = [
    [ 0,  0],
    [ 0, -1],
    [ 1, -1],
    [ 1,  0],
    [ 1,  1],
    [ 0,  1],
    [-1,  1],
    [-1,  0],
    [-1, -1]
];

export const DIRECTION_COORDS_3D: [number, number, number][] = [];
export const DIRECTION_NAMES_3D: string[] = [];
export const DIRECTION_NAMES_3D_INVERSE: Record<string, string> = {};

const nums = Array(3).fill(0).map((_, i) => i-1)
nums.map(x =>
    nums.map(y =>
        nums.map(z => {
            if (x === 0 && y === 0 && z === 0) return;
            DIRECTION_COORDS_3D.push([ x, y, z ]);
            DIRECTION_NAMES_3D.push(getDirectionString(x, y, z));
            DIRECTION_NAMES_3D_INVERSE[getDirectionString(x, y, z)] = getDirectionString(-x, -y, -z);
        })
    )
);

export const TIME_NAMES = ["was", "is", "will be"];

================
File: src/app/syllogimous/constants/local-storage.constants.ts
================
export const LS_DONT_SHOW = "SYL_DONT_SHOW:";

export const LS_SCORE = "SYL_SCORE";

export const LS_HISTORY = "SYL_HISTORY";

export const LS_TIMER = "SYL_TIMER_TYPE";

================
File: src/app/syllogimous/constants/syllogimous.constants.ts
================
import { ISettings } from "../models/settings.models";
import { EnumTiers } from "../models/syllogimous.models";

export const TIER_COLORS: Record<string, {bgColor: string, textColor: string}> = {
    [EnumTiers.Adept]: { bgColor: "#F0F8FF", textColor: "#045D56" },  // Alice Blue with Teal
    [EnumTiers.Savant]: { bgColor: "#E6E6FA", textColor: "#4B0082" },  // Lavender with Indigo
    [EnumTiers.Mastermind]: { bgColor: "#DDA0DD", textColor: "#483D8B" },  // Plum with Dark Slate Blue
    [EnumTiers.Visionary]: { bgColor: "#B0E0E6", textColor: "#002366" },  // Powder Blue with Royal Blue
    [EnumTiers.Genius]: { bgColor: "#AFEEEE", textColor: "#004953" },  // Pale Turquoise with Deep Aqua
    [EnumTiers.Luminary]: { bgColor: "#98FB98", textColor: "#006400" },  // Pale Green with Dark Green
    [EnumTiers.Prodigy]: { bgColor: "#FFFACD", textColor: "#556B2F" },  // Lemon Chiffon with Dark Olive Green
    [EnumTiers.Oracle]: { bgColor: "#FFDAB9", textColor: "#A0522D" },  // Peach Puff with Sienna
    [EnumTiers.Sage]: { bgColor: "#FFC0CB", textColor: "#8B0000" },  // Pink with Dark Red
    [EnumTiers.Philosopher]: { bgColor: "#D8BFD8", textColor: "#4A235A" },  // Thistle with Dark Purple
    [EnumTiers.Mystic]: { bgColor: "#C71585", textColor: "#FFE4E1" },  // Medium Violet Red with Misty Rose
    [EnumTiers.Transcendent]: { bgColor: "#4B0082", textColor: "#F0F8FF" }   // Indigo with Alice Blue
};

export const TIER_SCORE_RANGES: Record<string, { minScore: number, maxScore: number }> = {
    [EnumTiers.Adept]: { minScore: -Infinity, maxScore: 99 },
    [EnumTiers.Savant]: { minScore: 100, maxScore: 249 },
    [EnumTiers.Mastermind]: { minScore: 250, maxScore: 549 },
    [EnumTiers.Visionary]: { minScore: 550, maxScore: 999 },
    [EnumTiers.Genius]: { minScore: 1000, maxScore: 1599 },
    [EnumTiers.Luminary]: { minScore: 1600, maxScore: 2399 },
    [EnumTiers.Prodigy]: { minScore: 2400, maxScore: 3399 },
    [EnumTiers.Oracle]: { minScore: 3400, maxScore: 4599 },
    [EnumTiers.Sage]: { minScore: 4600, maxScore: 5999 },
    [EnumTiers.Philosopher]: { minScore: 6000, maxScore: 7599 },
    [EnumTiers.Mystic]: { minScore: 7600, maxScore: 9399 },
    [EnumTiers.Transcendent]: { minScore: 9400, maxScore: Infinity }
};

export const TIER_SCORE_ADJUSTMENTS: Record<string, { increment: number, decrement: number }> = {
    [EnumTiers.Adept]: { increment: 10, decrement: 5 },
    [EnumTiers.Savant]: { increment: 10, decrement: 5 },
    [EnumTiers.Mastermind]: { increment: 10, decrement: 5 },
    [EnumTiers.Visionary]: { increment: 10, decrement: 5 },
    [EnumTiers.Genius]: { increment: 10, decrement: 5 },
    [EnumTiers.Luminary]: { increment: 10, decrement: 5 },
    [EnumTiers.Prodigy]: { increment: 5, decrement: 5 },
    [EnumTiers.Oracle]: { increment: 5, decrement: 5 },
    [EnumTiers.Sage]: { increment: 5, decrement: 5 },
    [EnumTiers.Philosopher]: { increment: 5, decrement: 5 },
    [EnumTiers.Mystic]: { increment: 5, decrement: 5 },
    [EnumTiers.Transcendent]: { increment: 5, decrement: 5 }
};

// Minimum premises for analogy is 3
// Minimum premises for binary is 4

export const TIER_SETTINGS: Record<EnumTiers, ISettings> = {
    [EnumTiers.Adept]: {
        enableMeaningfulWords:   true,
        enableMeta:              false,
        enableNegation:          false,

        distinction:             [ true,  2, 90 ],
        comparisonNumerical:     [ true,  2, 90 ],
        comparisonChronological: [ true,  2, 90 ],
        direction:               [ false, 2, 90 ],
        syllogism:               [ false, 2, 90 ],
        direction3D:             [ false, 2, 90 ],
        direction4D:             [ false, 2, 90 ],
        analogy:                 [ false, 3, 90 ],
        binary:                  [ false, 4, 90 ],

        enableAnd:               false,
        enableOr:                false,
        enableNand:              false,
        enableNor:               false,
        enableXor:               false,
        enableXnor:              false,
    },
    [EnumTiers.Savant]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          false,

        distinction:             [ true,  3, 90 ],
        comparisonNumerical:     [ true,  3, 90 ],
        comparisonChronological: [ true,  3, 90 ],
        direction:               [ true,  3, 90 ],
        syllogism:               [ true,  3, 90 ],
        direction3D:             [ false, 2, 90 ],
        direction4D:             [ false, 2, 90 ],
        analogy:                 [ false, 3, 90 ],
        binary:                  [ false, 4, 90 ],

        enableAnd:               false,
        enableOr:                false,
        enableNand:              false,
        enableNor:               false,
        enableXor:               false,
        enableXnor:              false,
    },
    [EnumTiers.Mastermind]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          false,

        distinction:             [ true,  4, 90 ],
        comparisonNumerical:     [ true,  4, 90 ],
        comparisonChronological: [ true,  4, 90 ],
        direction:               [ true,  3, 90 ],
        syllogism:               [ true,  3, 90 ],
        direction3D:             [ true,  2, 90 ],
        direction4D:             [ true,  2, 90 ],
        analogy:                 [ false, 3, 90 ],
        binary:                  [ false, 4, 90 ],

        enableAnd:               false,
        enableOr:                false,
        enableNand:              false,
        enableNor:               false,
        enableXor:               false,
        enableXnor:              false,
    },
    [EnumTiers.Visionary]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          false,

        distinction:             [ true,  4, 90 ],
        comparisonNumerical:     [ true,  4, 90 ],
        comparisonChronological: [ true,  4, 90 ],
        direction:               [ true,  4, 90 ],
        syllogism:               [ true,  4, 90 ],
        direction3D:             [ true,  3, 90 ],
        direction4D:             [ true,  3, 90 ],
        analogy:                 [ true,  3, 90 ],
        binary:                  [ false, 4, 90 ],

        enableAnd:               false,
        enableOr:                false,
        enableNand:              false,
        enableNor:               false,
        enableXor:               false,
        enableXnor:              false,
    },
    [EnumTiers.Genius]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  5, 90 ],
        comparisonNumerical:     [ true,  5, 90 ],
        comparisonChronological: [ true,  5, 90 ],
        direction:               [ true,  4, 90 ],
        syllogism:               [ true,  4, 90 ],
        direction3D:             [ true,  3, 90 ],
        direction4D:             [ true,  3, 90 ],
        analogy:                 [ true,  3, 90 ],
        binary:                  [ true,  4, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              false,
        enableNor:               false,
        enableXor:               false,
        enableXnor:              false,
    },
    [EnumTiers.Luminary]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  5, 90 ],
        comparisonNumerical:     [ true,  5, 90 ],
        comparisonChronological: [ true,  5, 90 ],
        direction:               [ true,  5, 90 ],
        syllogism:               [ true,  5, 90 ],
        direction3D:             [ true,  4, 90 ],
        direction4D:             [ true,  4, 90 ],
        analogy:                 [ true,  4, 90 ],
        binary:                  [ true,  4, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Prodigy]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  6, 90 ],
        comparisonNumerical:     [ true,  6, 90 ],
        comparisonChronological: [ true,  6, 90 ],
        direction:               [ true,  6, 90 ],
        syllogism:               [ true,  5, 90 ],
        direction3D:             [ true,  4, 90 ],
        direction4D:             [ true,  4, 90 ],
        analogy:                 [ true,  4, 90 ],
        binary:                  [ true,  4, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Oracle]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  7, 90 ],
        comparisonNumerical:     [ true,  7, 90 ],
        comparisonChronological: [ true,  7, 90 ],
        direction:               [ true,  6, 90 ],
        syllogism:               [ true,  6, 90 ],
        direction3D:             [ true,  5, 90 ],
        direction4D:             [ true,  5, 90 ],
        analogy:                 [ true,  5, 90 ],
        binary:                  [ true,  5, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Sage]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  7, 90 ],
        comparisonNumerical:     [ true,  7, 90 ],
        comparisonChronological: [ true,  7, 90 ],
        direction:               [ true,  7, 90 ],
        syllogism:               [ true,  7, 90 ],
        direction3D:             [ true,  6, 90 ],
        direction4D:             [ true,  6, 90 ],
        analogy:                 [ true,  6, 90 ],
        binary:                  [ true,  6, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Philosopher]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  8, 90 ],
        comparisonNumerical:     [ true,  8, 90 ],
        comparisonChronological: [ true,  8, 90 ],
        direction:               [ true,  8, 90 ],
        syllogism:               [ true,  7, 90 ],
        direction3D:             [ true,  7, 90 ],
        direction4D:             [ true,  7, 90 ],
        analogy:                 [ true,  6, 90 ],
        binary:                  [ true,  6, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Mystic]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  9, 90 ],
        comparisonNumerical:     [ true,  9, 90 ],
        comparisonChronological: [ true,  9, 90 ],
        direction:               [ true,  9, 90 ],
        syllogism:               [ true,  8, 90 ],
        direction3D:             [ true,  8, 90 ],
        direction4D:             [ true,  8, 90 ],
        analogy:                 [ true,  7, 90 ],
        binary:                  [ true,  7, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    },
    [EnumTiers.Transcendent]: {
        enableMeaningfulWords:   true,
        enableMeta:              true,
        enableNegation:          true,

        distinction:             [ true,  9, 90 ],
        comparisonNumerical:     [ true,  9, 90 ],
        comparisonChronological: [ true,  9, 90 ],
        direction:               [ true,  9, 90 ],
        syllogism:               [ true,  9, 90 ],
        direction3D:             [ true,  9, 90 ],
        direction4D:             [ true,  9, 90 ],
        analogy:                 [ true,  8, 90 ],
        binary:                  [ true,  8, 90 ],

        enableAnd:               true,
        enableOr:                true,
        enableNand:              true,
        enableNor:               true,
        enableXor:               true,
        enableXnor:              true,
    }
}

================
File: src/app/syllogimous/models/question.models.ts
================
export enum EnumQuestionType {
    Syllogism = "Syllogism",
    Distinction = "Distinction",
    ComparisonNumerical = "Comparison Numerical",
    ComparisonChronological = "Comparison Chronological",
    Binary = "Binary",
    Direction = "Direction",
    Direction3D = "Direction3D",
    Direction4D = "Direction4D",
    Analogy = "Analogy",
}

export class Question {
    type: EnumQuestionType;
    isValid = false;
    rule = "";
    bucket: string[] = [];
    buckets: string[][][] = [];
    wordCoordMap: Record<string, [number, number] | [number, number, number] | [number, number, number, number]> = {};
    premises: string[] = [];
    conclusion = "";
    createdAt = new Date().getTime();
    answeredAt = new Date().getTime();
    userAnswer?: boolean;

    constructor(
        type: EnumQuestionType
    ) {
        this.type = type;
    }
}

================
File: src/app/syllogimous/models/settings.models.ts
================
export interface Picked<T> {
    picked: T[];
    remaining: T[];
}

export interface ISettings {
    enableMeaningfulWords: boolean;
    enableMeta: boolean;
    enableNegation: boolean;
    distinction: [ boolean, number, number ];
    comparisonNumerical: [ boolean, number, number ];
    comparisonChronological: [ boolean, number, number ];
    direction: [ boolean, number, number ];
    syllogism: [ boolean, number, number ];
    direction3D: [ boolean, number, number ];
    direction4D: [ boolean, number, number ];
    analogy: [ boolean, number, number ];
    binary: [ boolean, number, number ];
    enableAnd: boolean;
    enableNand: boolean;
    enableOr: boolean;
    enableNor: boolean;
    enableXor: boolean;
    enableXnor: boolean;
}

================
File: src/app/syllogimous/models/syllogimous.models.ts
================
export enum EnumScreens {
    Intro = "Intro",
    Start = "Start",
    Tutorial = "Tutorial",
    Game = "Game",
    Feedback = "Feedback",
    History = "History",
    Tutorials = "Tutorials",
    Stats = "Stats",
}

export enum EnumTiers {
    Adept = "Adept",
    Savant = "Savant",
    Mastermind = "Mastermind",
    Visionary = "Visionary",
    Genius = "Genius",
    Luminary = "Luminary",
    Prodigy = "Prodigy",
    Oracle = "Oracle",
    Sage = "Sage",
    Philosopher = "Philosopher",
    Mystic = "Mystic",
    Transcendent = "Transcendent",
}

================
File: src/app/syllogimous/pages/feedback/feedback.component.css
================
.feedback-wrap {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
    display: grid;
    place-items: center;
    border-radius: 0 0 var(--border-radius_md) var(--border-radius_md);
}

.feedback-correct {
    background: linear-gradient(to bottom, #0000, #D4EDDA 50%, #D4EDDA);
    color: #155724;
}

.feedback-incorrect {
    background: linear-gradient(to bottom, #0000, #F8D7DA 50%, #F8D7DA);
    color: #721C24;
}

.feedback-timeout {
    background: linear-gradient(to bottom, #0000, #E0E0E0 50%, #E0E0E0);
    color: #424242;
}

================
File: src/app/syllogimous/pages/feedback/feedback.component.html
================
<app-card>
    <div
        body
        *ngIf="{
            timeout: sylSrv.question.userAnswer === undefined,
            validity: sylSrv.question.userAnswer === sylSrv.question.isValid
        } as d"
        class="feedback-wrap"
        [class.feedback-timeout]="d.timeout"
        [class.feedback-correct]="!d.timeout && d.validity"
        [class.feedback-incorrect]="!d.timeout && !d.validity"
    >
        <div class="fs-1 fw-bold text-uppercase">
            {{ d.timeout ? "Timeout" : d.validity ? "Correct": "Incorrect" }}
        </div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/feedback/feedback.component.ts
================
import { Component } from '@angular/core';
import { SyllogimousService } from '../../services/syllogimous.service';

@Component({
    selector: 'app-feedback',
    templateUrl: './feedback.component.html',
    styleUrls: ['./feedback.component.css']
})
export class FeedbackComponent {
    constructor(
        public sylSrv: SyllogimousService
    ) { }
}

================
File: src/app/syllogimous/pages/game/game.component.css
================
.battlefield {
    font-size: 1.5rem;
}

.timerbar {
    position: absolute;
    width: 100%;
    left: 0;
    top: 0;
    border-radius: 0;
    height: 4px;
}

================
File: src/app/syllogimous/pages/game/game.component.html
================
<app-card>
    <div body class="battlefield">
        <ngb-progressbar *ngIf="timerType != 0" class="timerbar" type="success" [value]="100 * timerLeft / timerFull"></ngb-progressbar>
    
        <small class="d-block text-muted">Premises</small>
        <div *ngFor="let p of sylSrv.question.premises" class="premise" [innerHTML]="p"></div>
    
        <small class="d-block text-muted mt-3">Conclusion</small>
        <div class="conclusion" [innerHTML]="sylSrv.question.conclusion"></div>
    </div>

    <div footer class="d-flex gap-3 justify-content-center">
        <button class="btn btn-lg btn-danger col-3" (click)="sylSrv.checkQuestion(false)">False</button>
        <button class="btn btn-lg btn-success col-3" (click)="sylSrv.checkQuestion(true)">True</button>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/game/game.component.ts
================
import { Component } from '@angular/core';
import { SyllogimousService } from '../../services/syllogimous.service';
import { StatsService } from '../../services/stats.service';
import { LS_TIMER } from '../../constants/local-storage.constants';
import { EnumQuestionType } from '../../models/question.models';

@Component({
    selector: 'app-game',
    templateUrl: './game.component.html',
    styleUrls: ['./game.component.css']
})
export class GameComponent {
    timerType = 0;
    timerFull = 0;
    timerLeft = 0;
    timer: any;

    constructor(
        public sylSrv: SyllogimousService,
        private statsService: StatsService,
    ) { }

    ngOnInit() {
        this.timerType = JSON.parse(localStorage.getItem(LS_TIMER) || '0');

        switch(this.timerType) {
            case 1: {
                console.log("Fixed timer");

                switch(this.sylSrv.question.type) {
                    case EnumQuestionType.Syllogism: {
                        this.timerFull = this.sylSrv.settings.syllogism[2];
                        break;
                    }
                    case EnumQuestionType.Distinction: {
                        this.timerFull = this.sylSrv.settings.distinction[2];
                        break;
                    }
                    case EnumQuestionType.ComparisonNumerical: {
                        this.timerFull = this.sylSrv.settings.comparisonNumerical[2];
                        break;
                    }
                    case EnumQuestionType.ComparisonChronological: {
                        this.timerFull = this.sylSrv.settings.comparisonChronological[2];
                        break;
                    }
                    case EnumQuestionType.Binary: {
                        this.timerFull = this.sylSrv.settings.binary[2];
                        break;
                    }
                    case EnumQuestionType.Direction: {
                        this.timerFull = this.sylSrv.settings.direction[2];
                        break;
                    }
                    case EnumQuestionType.Direction3D: {
                        this.timerFull = this.sylSrv.settings.direction3D[2];
                        break;
                    }
                    case EnumQuestionType.Direction4D: {
                        this.timerFull = this.sylSrv.settings.direction4D[2];
                        break;
                    }
                    case EnumQuestionType.Analogy: {
                        this.timerFull = this.sylSrv.settings.analogy[2];
                        break;
                    }
                }
                
                this.timerLeft = this.timerFull;
                this.timer = this.kickTimer();

                break;
            }
            case 2: {
                console.log("Adaptive timer");

                const lowerBound = 15;
                const correctRate = 0.5;
                const incorrectRate = 1.5;
                const timeoutRate = 2.5;
                this.timerFull = 90;

                this.statsService.calcStats();
                const questionType = this.sylSrv.question.type;
                const questionPremises = this.sylSrv.question.premises.length;
                const typeBasedStats = this.statsService.typeBasedStats[questionType];

                if (typeBasedStats?.stats) {
                    const prevStats = typeBasedStats.stats[questionPremises - 1];
                    const currStats = typeBasedStats.stats[questionPremises];

                    let avgTimeToRespond = this.timerFull;
                    if (currStats && currStats.count > 4) {
                        avgTimeToRespond = currStats.last10Sum / (1000 * currStats.last10Count);
                        avgTimeToRespond -= correctRate * currStats.last10Correct;
                        avgTimeToRespond += incorrectRate * currStats.last10Incorrect;
                        avgTimeToRespond += timeoutRate * currStats.last10Timeout;
                    } else if (prevStats && prevStats.count > 4) {
                        avgTimeToRespond = prevStats.last10Sum / (1000 * prevStats.last10Count);
                        avgTimeToRespond += lowerBound; // Bonus for the new level
                        avgTimeToRespond -= correctRate * prevStats.last10Correct;
                        avgTimeToRespond += incorrectRate * prevStats.last10Incorrect;
                        avgTimeToRespond += timeoutRate * prevStats.last10Timeout;
                    }

                    this.timerFull = Math.max(lowerBound, avgTimeToRespond);
                }

                this.timerLeft = this.timerFull;
                this.timer = this.kickTimer();
                
                break;
            }
            default: {
                console.log("No timer");
            }
        }
    }

    ngOnDestroy() {
        if (this.timer) {
            clearInterval(this.timer);
        }
    }

    kickTimer = () => {
        return setInterval(() => {
            this.timerLeft -= 1;
            if (this.timerLeft < 0) {
                this.sylSrv.checkQuestion();
            }
        }, 1000);
    }
}

================
File: src/app/syllogimous/pages/history/history.component.css
================
[body] {
    position: absolute;
    width: 100%;
    max-height: 100%;
    overflow: auto;
}

.correct {
    background-color: #D4EDDA;
    color: #155724;
}

.incorrect {
    background-color: #F8D7DA;
    color: #721C24;
}

.timeout {
    background-color: #E0E0E0;
    color: #424242;
}

================
File: src/app/syllogimous/pages/history/history.component.html
================
<app-card>
    <div body>
        <div class="text-center" *ngIf="!questions.length">
            <h3 class="mb-3">Play to see something here</h3>
            <button class="btn btn-lg btn-primary" (click)="sylSrv.start()">Press to Play</button>
        </div>
        
        <ul class="list-group list-group-flush" *ngIf="questions.length">
            <li
                class="list-group-item"
                *ngFor="let q of questions"
                [class.timeout]="q.userAnswer === undefined"
                [class.correct]="q.userAnswer !== undefined && q.userAnswer === q.isValid"
                [class.incorrect]="q.userAnswer !== undefined && q.userAnswer !== q.isValid"
            >
                <div class="p-2 overflow-auto" style="max-height: 150px; border: 1px solid;">
                    <div *ngFor="let p of q.premises" class="premise" [innerHTML]="p"></div>
                    <div [innerHTML]="q.conclusion"></div>
                </div>
        
                <small class="d-grid mt-2 px-2" style="grid-template-columns: repeat(4, 1fr); gap: 0.25rem;">
                    <div>
                        <div class="fw-bold">Type</div>
                        {{ q.type }}
                    </div>
        
                    <div>
                        <div class="fw-bold">Correct Answer</div>
                        {{ q.isValid }}
                    </div>
        
                    <div>
                        <div class="fw-bold">User Answer</div>
                        {{ (q.userAnswer === undefined) ? "Timeout" : q.userAnswer }}
                    </div>
        
                    <div>
                        <div class="fw-bold">Time Taken</div>
                        {{ (q.userAnswer === undefined) ? "Timeout" : (((q.answeredAt - q.createdAt) / 1000) | number:".1-1") + "s" }}
                    </div>
                </small>
            </li>
        </ul>
    </div>

    <div footer class="playcard-toolbar">
        <div>
            <button
                class="btn btn-outline-primary"
                (click)="router.navigate([EnumScreens.Start]);"
            >
                <i class="bi bi-arrow-left"></i> Go to Start
            </button>
        </div>
        <div>{{ questions.length }} questions</div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/history/history.component.ts
================
import { Component } from '@angular/core';
import { SyllogimousService } from '../../services/syllogimous.service';
import { Question } from '../../models/question.models';
import { EnumScreens } from '../../models/syllogimous.models';
import { Router } from '@angular/router';

@Component({
    selector: 'app-history',
    templateUrl: './history.component.html',
    styleUrls: ['./history.component.css']
})
export class HistoryComponent {
    EnumScreens = EnumScreens;
    questions: Question[] = [];
    
    constructor(
        public sylSrv: SyllogimousService,
        public router: Router
    ) { }

    ngOnInit() {
        this.questions = this.sylSrv.questionsFromLS;
    }
}

================
File: src/app/syllogimous/pages/intro/intro.component.html
================
<app-card>
    <div body>
        <h1>Welcome to Syllogimous!</h1>
        <p>Syllogimous takes classic logic challenges and turns them into brain workout. Get ready to test yourself, this is your chance to stretch your mind to its full potential.</p>
    
        <h2>Adaptive Difficulty</h2>
        <p>This game adapts to how well you're doing. As you level up/down, the difficulty adjusts to ensure you're always challenged, helping you sharpen your brain every step of the way. With each new level you'll face more types of puzzles and more premises, this pushes your cognitive abilities further.</p>
        
        <h2>Why This Is Great for You</h2>
        <p>Research shows that relational training can significantly improve cognitive functions, such as language skills, advanced problem-solving, and learning abilities. This type of training, which is based on Relational Frame Theory (RFT), is at the heart of Syllogimous. By playing Syllogimous, you're boosting your problem-solving skills, hopefully while having fun.</p>
        
        <h2>Useful Links</h2>
        <div class="d-grid gap-1">
            <a href="https://en.wikipedia.org/wiki/Relational_frame_theory" target="_blank">Relational Frame Theory Wikipedia</a>
            <a href="https://groups.google.com/g/brain-training" target="_blank">Brain Training Google Groups</a>
            <a href="https://t.me/brain_training" target="_blank">Brain Training Telegram</a>
        </div>
    </div>
    
    <div footer class="playcard-toolbar">
        <div>
            <div class="form-check">
                <input #dontShowAnymore class="form-check-input" type="checkbox" value="" id="dontShowAnymore">
                <label class="form-check-label" for="dontShowAnymore">
                    Don't show anymore
                </label>
            </div>
        </div>
        <div>
            <button
                class="btn btn-outline-primary"
                (click)="sylSrv.skipIntro(dontShowAnymore.checked)"
            >Skip Intro</button>
        </div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/intro/intro.component.ts
================
import { Component } from '@angular/core';
import { SyllogimousService } from '../../services/syllogimous.service';

@Component({
    selector: 'app-intro',
    templateUrl: './intro.component.html',
    styleUrls: ['./intro.component.css']
})
export class IntroComponent {
    constructor(
        public sylSrv: SyllogimousService
    ) { }
}

================
File: src/app/syllogimous/pages/start/start.component.css
================
input, label {
    cursor: pointer;
}

================
File: src/app/syllogimous/pages/start/start.component.html
================
<app-card>
    <div body style="min-width: 320px;">
        <h2 class="text-center">Start Screen</h2>
        
        <ul class="list-group mb-2">
            <li class="list-group-item flex-between">
                <b>Tier</b>
                <div>{{ sylSrv.tier }} ({{ sylSrv.score }} pts earned)</div>
            </li>
        
            <li class="list-group-item flex-between">
                <b>Next Tier</b>
                <div>{{ nextTier }} ({{ pointsRemaining }} pts left)</div>
            </li>
    
            <li class="list-group-item flex-between">
                <b>Correct Answers</b>
                <div>{{ correctQs.length }}</div>
            </li>
        
            <li class="list-group-item flex-between">
                <b>Incorrect Answers</b>
                <div>{{ incorrectQs.length }}</div>
            </li>
        
            <li class="list-group-item flex-between">
                <b>Unanswered Questions</b>
                <div>{{ unansweredQs.length }}</div>
            </li>
        
            <li class="list-group-item flex-between">
                <b>Current Streak</b>
                <div>{{ currentStreak.length }}</div>
            </li>
        
            <li class="list-group-item flex-between">
                <b>Longest Streak</b>
                <div>{{ longestStreak.length }}</div>
            </li>
        </ul>
    
        <div class="d-flex justify-content-evenly">
            <button class="btn btn-link" (click)="router.navigate([EnumScreens.Intro])">Intro</button>
            <button class="btn btn-link" (click)="router.navigate([EnumScreens.Stats])">Stats</button>
            <button class="btn btn-link" (click)="router.navigate([EnumScreens.History])">History</button>
            <button class="btn btn-link" (click)="router.navigate([EnumScreens.Tutorials])">Tutorials</button>
        </div>

        <div class="d-flex flex-between gap-2 pt-3">
            <input type="radio" id="timer-choice-0" name="timer-kind" (input)="setTimer(0)"> <label for="timer-choice-0" ngbTooltip="No timer at all">No timer</label>
            <input type="radio" id="timer-choice-1" name="timer-kind" (input)="setTimer(1)"> <label for="timer-choice-1" ngbTooltip="Fixed timer based on tier">Tier-based timer</label>
            <input type="radio" id="timer-choice-2" name="timer-kind" (input)="setTimer(2)"> <label for="timer-choice-2" ngbTooltip="Timer adapts as you play">Adaptive timer</label>
        </div>
    </div>

    <div footer class="text-center">
        <button class="btn btn-lg btn-primary" (click)="sylSrv.start()">Press to Play</button>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/start/start.component.ts
================
import { Component } from '@angular/core';
import { EnumScreens, EnumTiers } from '../../models/syllogimous.models';
import { TIER_SCORE_RANGES } from '../../constants/syllogimous.constants';
import { Question } from '../../models/question.models';
import { SyllogimousService } from '../../services/syllogimous.service';
import { Router } from '@angular/router';
import { LS_TIMER } from '../../constants/local-storage.constants';

@Component({
    selector: 'app-start',
    templateUrl: './start.component.html',
    styleUrls: ['./start.component.css']
})
export class StartComponent {
    EnumScreens = EnumScreens;

    TIER_SCORE_RANGES = TIER_SCORE_RANGES;
    tiers = Object.values(EnumTiers);
    nextTier = EnumTiers.Savant;
    pointsRemaining = 0;

    questions: Question[] = [];
    correctQs: Question[] = [];
    incorrectQs: Question[] = [];
    unansweredQs: Question[] = [];
    currentStreak: Question[] = [];
    longestStreak: Question[] = [];

    constructor(
        public sylSrv: SyllogimousService,
        public router: Router
    ) { }

    ngOnInit() {
        const currTierIdx = this.tiers.findIndex(tier => tier === this.sylSrv.tier);
        this.nextTier = this.tiers[currTierIdx + 1] || "--";
        this.pointsRemaining = this.nextTier ? (TIER_SCORE_RANGES[this.nextTier].minScore - this.sylSrv.score) : 0;

        this.questions = this.sylSrv.questionsFromLS;

        this.correctQs = this.questions.filter(q => q.userAnswer !== undefined && q.isValid === q.userAnswer);
        this.incorrectQs = this.questions.filter(q => q.userAnswer !== undefined && q.isValid !== q.userAnswer);
        this.unansweredQs = this.questions.filter(q => q.userAnswer === undefined);

        for (const q of this.questions) {
            if (q.isValid !== q.userAnswer) {
                break;
            }
            this.currentStreak.push(q);
        }

        let streak = [];
        for (const q of this.questions) {
            if (q.isValid !== q.userAnswer) {
                if (streak.length > this.longestStreak.length) {
                    this.longestStreak = streak;
                    streak = [];
                }
                continue;
            }
            streak.push(q);
        }
    }

    ngAfterViewInit() {
        const timerType = localStorage.getItem(LS_TIMER) || 0;
        (document.querySelector(`#timer-choice-${timerType}`) as HTMLInputElement).checked = true;
    }

    setTimer(timerType: number) {
        localStorage.setItem(LS_TIMER, JSON.stringify(timerType));
    }
}

================
File: src/app/syllogimous/pages/stats/accuracy-stats/accuracy-stats.component.html
================
<h2 class="text-center">Accuracy Stats</h2>
    
<ul class="list-group">
    <li class="list-group-item flex-between">
        <b>Correct Answers</b>
        <div>{{ correctQs.length }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Incorrect Answers</b>
        <div>{{ incorrectQs.length }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Unanswered Questions</b>
        <div>{{ unansweredQs.length }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Current Streak</b>
        <div>{{ currentStreak.length }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Longest Streak</b>
        <div>{{ longestStreak.length }}</div>
    </li>
</ul>

================
File: src/app/syllogimous/pages/stats/accuracy-stats/accuracy-stats.component.ts
================
import { Component } from '@angular/core';
import { Question } from 'src/app/syllogimous/models/question.models';
import { SyllogimousService } from 'src/app/syllogimous/services/syllogimous.service';

@Component({
    selector: 'app-accuracy-stats',
    templateUrl: './accuracy-stats.component.html',
    styleUrls: ['./accuracy-stats.component.css']
})
export class AccuracyStatsComponent {
    questions: Question[] = [];
    correctQs: Question[] = [];
    incorrectQs: Question[] = [];
    unansweredQs: Question[] = [];
    currentStreak: Question[] = [];
    longestStreak: Question[] = [];

    constructor(
        public sylSrv: SyllogimousService
    ) {}

    ngOnInit() {
        this.questions = this.sylSrv.questionsFromLS;

        this.correctQs = this.questions.filter(q => q.userAnswer !== undefined && q.isValid === q.userAnswer);
        this.incorrectQs = this.questions.filter(q => q.userAnswer !== undefined && q.isValid !== q.userAnswer);
        this.unansweredQs = this.questions.filter(q => q.userAnswer === undefined);

        for (const q of this.questions) {
            if (q.isValid !== q.userAnswer) {
                break;
            }
            this.currentStreak.push(q);
        }

        let streak = [];
        for (const q of this.questions) {
            if (q.isValid !== q.userAnswer) {
                if (streak.length > this.longestStreak.length) {
                    this.longestStreak = streak;
                    streak = [];
                }
                continue;
            }
            streak.push(q);
        }
    }
}

================
File: src/app/syllogimous/pages/stats/error-analysis/error-analysis.component.html
================
<h2 class="text-center">Error Analysis</h2>
    
<ul class="list-group">
    <li class="list-group-item flex-between">
        <b>Most Common Mistake Type</b>
        <div>{{ mostCommonMistake }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Least Common Mistake Type</b>
        <div>{{ leastCommonMistake }}</div>
    </li>
</ul>

================
File: src/app/syllogimous/pages/stats/error-analysis/error-analysis.component.ts
================
import { Component } from '@angular/core';
import { Question } from 'src/app/syllogimous/models/question.models';
import { SyllogimousService } from 'src/app/syllogimous/services/syllogimous.service';

@Component({
    selector: 'app-error-analysis',
    templateUrl: './error-analysis.component.html',
    styleUrls: ['./error-analysis.component.css']
})
export class ErrorAnalysisComponent {
    questions: Question[] = [];
    mostCommonMistake = "No Mistakes Yet";
    leastCommonMistake = "No Mistakes Yet";

    constructor(
        public sylSrv: SyllogimousService
    ) {}

    ngOnInit() {
        this.questions = this.sylSrv.questionsFromLS;

        const typeMistakesCount: Record<string, number> = {};
        this.questions
            .filter(q => q.isValid !== q.userAnswer)
            .forEach(q => {
                typeMistakesCount[q.type] = typeMistakesCount[q.type] || 0;
                typeMistakesCount[q.type]++;
            });
        const sorted = Object.entries(typeMistakesCount).sort((a, b) => a[1] - b[1]);
        if (sorted.length) {
            this.mostCommonMistake = sorted[sorted.length - 1][0];
            this.leastCommonMistake = sorted[0][0];
        }
    }
}

================
File: src/app/syllogimous/pages/stats/stats.component.html
================
<app-card>
    <div body class="d-grid gap-5" style="min-width: 320px;">
        <app-tier-stats></app-tier-stats>
        <app-accuracy-stats></app-accuracy-stats>
        <app-time-based-stats></app-time-based-stats>
        <app-type-based-stats></app-type-based-stats>
        <app-error-analysis></app-error-analysis>
    </div>

    <div footer class="playcard-toolbar">
        <div>
            <button
                class="btn btn-outline-primary"
                (click)="router.navigate([EnumScreens.Start])"
            >
                <i class="bi bi-arrow-left"></i> Go to Start
            </button>
        </div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/stats/stats.component.ts
================
import { Component } from '@angular/core';
import { EnumScreens } from '../../models/syllogimous.models';
import { Router } from '@angular/router';

@Component({
    selector: 'app-stats',
    templateUrl: './stats.component.html',
    styleUrls: ['./stats.component.css']
})
export class StatsComponent {
    EnumScreens = EnumScreens;

    constructor(
        public router: Router
    ) {}
}

================
File: src/app/syllogimous/pages/stats/tier-stats/tier-stats.component.html
================
<h2 class="text-center">Tier Stats</h2>
    
<ul class="list-group">
    <li class="list-group-item flex-between">
        <b>Tier</b>
        <div>{{ sylSrv.tier }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Points Earned</b>
        <div>{{ sylSrv.score }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Next Tier</b>
        <div>{{ nextTier }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Points Remaining to Next Tier</b>
        <div>{{ pointsRemaining }}</div>
    </li>
</ul>

================
File: src/app/syllogimous/pages/stats/tier-stats/tier-stats.component.ts
================
import { Component } from '@angular/core';
import { TIER_SCORE_RANGES } from 'src/app/syllogimous/constants/syllogimous.constants';
import { EnumTiers } from 'src/app/syllogimous/models/syllogimous.models';
import { SyllogimousService } from 'src/app/syllogimous/services/syllogimous.service';

@Component({
    selector: 'app-tier-stats',
    templateUrl: './tier-stats.component.html',
    styleUrls: ['./tier-stats.component.css']
})
export class TierStatsComponent {
    TIER_SCORE_RANGES = TIER_SCORE_RANGES;
    tiers = Object.values(EnumTiers);
    nextTier = EnumTiers.Savant;
    pointsRemaining = 0;

    constructor(
        public sylSrv: SyllogimousService
    ) {}

    ngOnInit() {
        const currTierIdx = this.tiers.findIndex(tier => tier === this.sylSrv.tier);
        this.nextTier = this.tiers[currTierIdx + 1] || "--";
        this.pointsRemaining = this.nextTier ? (TIER_SCORE_RANGES[this.nextTier].minScore - this.sylSrv.score) : 0;
    }
}

================
File: src/app/syllogimous/pages/stats/time-based-stats/time-based-stats.component.html
================
<ng-template #timeBasedStatsTemplate let-ps="ps" let-stats="stats">
    <ul class="list-group">
        <li class="list-group-item flex-between">
            <b>Average Time per Answer</b>
            <div>{{ (stats[ps] ? (stats[ps].sum / (1000 * stats[ps].count)) : 0) | number:".1-1" }} s</div>
        </li>

        <li class="list-group-item flex-between">
            <b>Fastest Answer</b>
            <div>{{ ((stats[ps]?.fastest / 1000) || 0) | number:".1-1" }} s</div>
        </li>

        <li class="list-group-item flex-between">
            <b>Slowest Answer</b>
            <div>{{ ((stats[ps]?.slowest / 1000) || 0) | number:".1-1" }} s</div>
        </li>
    </ul>
</ng-template>

<h2 class="text-center">Time-Based Stats</h2>

<ul class="list-group mb-3">
    <li class="list-group-item flex-between">
        <b>Total Play Time</b>
        <div>{{ formatTime(totalPlayTime) }}</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Average Time per Answer</b>
        <div>{{ ((questions.length !== 0) ? (totalPlayTime / (1000 * questions.length)) : 0) | number:".1-1" }} s</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Fastest Answer</b>
        <div>{{ ((fastestAnswer / 1000) || 0) | number:".1-1" }} s</div>
    </li>

    <li class="list-group-item flex-between">
        <b>Slowest Answer</b>
        <div>{{ ((slowestAnswer / 1000) || 0) | number:".1-1" }} s</div>
    </li>
</ul>

<div *ngIf="{ activeTab: 2 } as d">
    <ul
        ngbNav
        #nav="ngbNav"
        [(activeId)]="d.activeTab"
        class="nav-tabs"
    >
        <li [ngbNavItem]="2">
            <a ngbNavLink>2 Premises</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>

        <li [ngbNavItem]="3">
            <a ngbNavLink>3 Ps</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>

        <li [ngbNavItem]="4">
            <a ngbNavLink>4 Ps</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>

        <li [ngbNavItem]="5">
            <a ngbNavLink>5 Ps</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>

        <li [ngbNavItem]="6">
            <a ngbNavLink>6 Ps</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>

        <li [ngbNavItem]="7">
            <a ngbNavLink>7+ Ps</a>
            <ng-template ngbNavContent>
                <ng-container
                    *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: timeBasedStats }"
                ></ng-container>
            </ng-template>
        </li>
    </ul>

    <div
        [ngbNavOutlet]="nav"
        class="p-3 border border-top-0"
    ></div>
</div>

================
File: src/app/syllogimous/pages/stats/time-based-stats/time-based-stats.component.ts
================
import { Component } from '@angular/core';
import { Question } from 'src/app/syllogimous/models/question.models';
import { SyllogimousService } from 'src/app/syllogimous/services/syllogimous.service';
import { formatTime } from 'src/app/utils/date';

@Component({
    selector: 'app-time-based-stats',
    templateUrl: './time-based-stats.component.html',
    styleUrls: ['./time-based-stats.component.css']
})
export class TimeBasedStatsComponent {
    formatTime = formatTime;

    questions: Question[] = [];
    totalPlayTime = 0;
    avgAnswer = 0;
    fastestAnswer = 0;
    slowestAnswer = 0;
    timeBasedStats: Record<string, any> = {};

    constructor(
        private sylSrv: SyllogimousService
    ) {}

    ngOnInit() {
        this.questions = this.sylSrv.questionsFromLS;

        for (const q of this.questions) {
            const ps = q.premises.length;
            this.timeBasedStats[ps] = this.timeBasedStats[ps] || {
                sum: 0,
                count: 0,
                fastest: 0,
                slowest: 0,
            };

            const dt = q.answeredAt - q.createdAt;
            this.totalPlayTime += dt;

            this.timeBasedStats[ps].sum += dt;
            this.timeBasedStats[ps].count += 1;

            if (q.userAnswer !== undefined) {
                if (this.fastestAnswer === 0 || dt < this.fastestAnswer) {
                    this.fastestAnswer = dt;
                }
                if (this.slowestAnswer === 0 || dt > this.slowestAnswer) {
                    this.slowestAnswer = dt;
                }

                if (this.timeBasedStats[ps].fastest === 0 || dt < this.timeBasedStats[ps].fastest) {
                    this.timeBasedStats[ps].fastest = dt;
                }
                if (this.timeBasedStats[ps].slowest === 0 || dt > this.timeBasedStats[ps].slowest) {
                    this.timeBasedStats[ps].slowest = dt;
                }
            }
        }
    }
}

================
File: src/app/syllogimous/pages/stats/type-based-stats/type-based-stats.component.html
================
<ng-template #timeBasedStatsTemplate let-ps="ps" let-stats="stats">
    <ul class="list-group">
        <li class="list-group-item">
            <b>Average Time per Answer</b>
            <div>{{ (stats[ps] ? (stats[ps].sum / (1000 * stats[ps].count)) : 0) | number:".1-1" }} s</div>
        </li>

        <li class="list-group-item">
            <b>Fastest Answer</b>
            <div>{{ ((stats[ps]?.fastest / 1000) || 0) | number:".1-1" }} s</div>
        </li>

        <li class="list-group-item">
            <b>Slowest Answer</b>
            <div>{{ ((stats[ps]?.slowest / 1000) || 0) | number:".1-1" }} s</div>
        </li>
    </ul>
</ng-template>

<div class="p-3 border rounded text-center" *ngIf="!statsService.types.length">
    <h2>Type-Based Stats</h2>
    <h4 class="my-3">Play to see something here</h4>
    <button class="btn btn-lg btn-primary" (click)="sylSrv.start()">Press to Play</button>
</div>

<div class="d-grid gap-5">
    <div *ngFor="let type of statsService.types">
        <h2 class="text-center">{{ type }} Stats</h2>
    
        <ul class="list-group my-3">
            <li class="list-group-item">
                <b>Completed Questions</b>
                <div>{{ statsService.typeBasedStats[type].completed }}</div>
            </li>
    
            <li class="list-group-item">
                <b>Accuracy</b>
                <div>{{ statsService.typeBasedStats[type].accuracy | percent }}</div>
            </li>
        </ul>
    
        <div *ngIf="{ activeTab: 2 } as d">
            <ul ngbNav #nav="ngbNav" [(activeId)]="d.activeTab" class="nav-tabs">
                <li [ngbNavItem]="2">
                    <a ngbNavLink>2 Premises</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
    
                <li [ngbNavItem]="3">
                    <a ngbNavLink>3 Ps</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
    
                <li [ngbNavItem]="4">
                    <a ngbNavLink>4 Ps</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
    
                <li [ngbNavItem]="5">
                    <a ngbNavLink>5 Ps</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
    
                <li [ngbNavItem]="6">
                    <a ngbNavLink>6 Ps</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
    
                <li [ngbNavItem]="7">
                    <a ngbNavLink>7+ Ps</a>
                    <ng-template ngbNavContent>
                        <ng-container *ngTemplateOutlet="timeBasedStatsTemplate; context: { ps: d.activeTab, stats: statsService.typeBasedStats[type].stats }"></ng-container> 
                    </ng-template>
                </li>
            </ul>
            
            <div [ngbNavOutlet]="nav" class="p-3 border border-top-0"></div>
        </div>
    </div>
</div>

================
File: src/app/syllogimous/pages/stats/type-based-stats/type-based-stats.component.ts
================
import { Component } from '@angular/core';
import { StatsService } from 'src/app/syllogimous/services/stats.service';
import { SyllogimousService } from 'src/app/syllogimous/services/syllogimous.service';

@Component({
    selector: 'app-type-based-stats',
    templateUrl: './type-based-stats.component.html',
    styleUrls: ['./type-based-stats.component.css']
})
export class TypeBasedStatsComponent {

    constructor(
        public sylSrv: SyllogimousService,
        public statsService: StatsService,
    ) { }

    ngOnInit() {
        this.statsService.calcStats();
    }
}

================
File: src/app/syllogimous/pages/tutorial/analogy/analogy.component.html
================
<h2>How to Play Analogy</h2>
    
<h3>Step 1</h3>
<p>Each analogy question begins with a set of statements that define the relationships between different items. For example:</p>
<ul>
    <li><strong>Statement 1:</strong> Brush is the same as Desk</li>
    <li><strong>Statement 2:</strong> Desk is opposite of Bread</li>
    <li><strong>Statement 3:</strong> Skirt is opposite of Heart</li>
    <li><strong>Statement 4:</strong> Bread is the same as Skirt</li>
</ul>
<p>These statements provide the groundwork for understanding how each item relates to the others.</p>

<h3>Step 2</h3>
<p>After reviewing the relationships, you'll be presented with an analogy that you need to evaluate. For example:</p>
<p><strong>Analogy to Evaluate:</strong> "Heart to Bread is the same as Skirt to Desk."</p>
<p>Your task is to determine whether the relationship between "Heart and Bread" is equivalent to the relationship between "Skirt and Desk."</p>

<h3>Step 3</h3>
<p>To solve the analogy, follow these steps:</p>
<ol>
    <li><strong>Identify the relationships</strong> between the items in each pair.
        <ul>
            <li>From Statement 3: "Skirt is opposite of Heart."</li>
            <li>From Statement 4: "Bread is the same as Skirt."</li>
            <li>From Statement 2: "Desk is opposite of Bread."</li>
        </ul>
    </li>
    <li><strong>Map the relationships</strong> to the analogy:
        <ul>
            <li><strong>"Heart to Bread":</strong> Since "Bread is the same as Skirt" and "Skirt is opposite of Heart," the relationship here is one of opposition.</li>
            <li><strong>"Skirt to Desk":</strong> Since "Bread is the same as Skirt" and "Desk is opposite of Bread," the relationship here is also one of opposition.</li>
        </ul>
    </li>
    <li><strong>Determine consistency:</strong> Both "Heart to Bread" and "Skirt to Desk" have an "opposite" relationship. Therefore, the analogy is consistent.</li>
</ol>

<h3>Step 4</h3>
<p>After analyzing the relationships, you need to decide whether the analogy holds true:</p>
<ul>
    <li>If the relationships match, click <strong>True</strong>.</li>
    <li>If they do not match, click <strong>False</strong>.</li>
</ul>
<p>In this example, since both pairs have an opposite relationship, you would select <strong>True</strong>.</p>
<p>Once you've made your selection, the game will give you feedback, helping you to learn from your choices and improve your ability to recognize patterns in analogies.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Break down the relationships:</strong> Focus on one pair at a time to avoid confusion.</li>
    <li><strong>Practice regularly:</strong> Familiarity with different types of relationships will help you solve analogies more quickly and accurately.</li>
</ul>

<p>By following these steps, you'll be better equipped to tackle analogy questions, improving your pattern recognition and logical reasoning skills!</p>

================
File: src/app/syllogimous/pages/tutorial/analogy/analogy.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-analogy",
    templateUrl: "./analogy.component.html",
    styleUrls: ["./analogy.component.css"]
})
export class TutorialAnalogyComponent {}

================
File: src/app/syllogimous/pages/tutorial/binary/binary.component.html
================
<h2>How to Play Binary</h2>
<p>In the binary type questions, you need to evaluate whether a specific logical statement (or set of statements) is true or false based on the relationships given. These questions often involve comparing elements or determining relationships between them using logical operators like <strong>same as</strong>, <strong>opposite of</strong>, and <strong>or</strong>.</p>

<h3>Step 1</h3>
<p>Each binary question starts with a set of relationships between different items. Here’s an example:</p>
<ul>
    <li><strong>Statement 1:</strong> Jaw is same as Foot</li>
    <li><strong>Statement 2:</strong> Foot is opposite of Barbie</li>
    <li><strong>Statement 3:</strong> No Violin is Cashier</li>
    <li><strong>Statement 4:</strong> All Violin is Paint</li>
    <li><strong>Statement 5:</strong> Jaw is same as Barbie</li>
</ul>
<p><strong>Binary Question:</strong> "Jaw is same as Barbie <em>or</em> No Cashier is Paint"</p>

<h3>Step 2</h3>
<p>To solve the binary question, analyze the relationships described in each statement:</p>
<ul>
    <li><strong>Statement 1:</strong> "Jaw is same as Foot" means that whatever is true of the Jaw should also be true of the Foot.</li>
    <li><strong>Statement 2:</strong> "Foot is opposite of Barbie" means that the characteristics of Foot are entirely different from Barbie.</li>
    <li><strong>Statement 3:</strong> "No Violin is Cashier" suggests that Violin and Cashier do not overlap in any way.</li>
    <li><strong>Statement 4:</strong> "All Violin is Paint" indicates that every Violin is also classified as Paint.</li>
    <li><strong>Statement 5:</strong> "Jaw is same as Barbie" contradicts Statement 2, since if Jaw is the same as Foot, and Foot is opposite of Barbie, Jaw cannot logically be the same as Barbie.</li>
</ul>

<h3>Step 3</h3>
<p>Now, consider the binary question:</p>
<blockquote><strong>Binary Question:</strong> "Jaw is same as Barbie <em>or</em> No Cashier is Paint"</blockquote>
<p>This question uses the logical operator <strong>or</strong>, meaning that the entire statement is true if <strong>either</strong> "Jaw is same as Barbie" <strong>or</strong> "No Cashier is Paint" is true.</p>
<ul>
    <li>From the analysis, "Jaw is same as Barbie" should be false because it contradicts the earlier statements.</li>
    <li>"No Cashier is Paint" might be true, based on the third and fourth statements, but we need to confirm.</li>
</ul>
<p>Since the binary question requires only one part of the statement to be true for the entire statement to be true, if you determine "No Cashier is Paint" is true, then the answer to the binary question would be <strong>True</strong>.</p>

<h3>Step 4</h3>
<p>After analyzing, click the <strong>True</strong> button if you believe the binary question is logically correct, or the <strong>False</strong> button if you believe it is not.</p>
<p>After making your choice, you’ll receive feedback on whether your answer was correct, helping you understand the logical structure better.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Carefully evaluate contradictions:</strong> Pay close attention to any potential contradictions in the statements.</li>
    <li><strong>Use logical operators wisely:</strong> Understand how "or," "and," and other operators affect the truth value of statements.</li>
</ul>

<p>By following these steps, you can master binary type questions, enhancing your ability to reason through complex logical puzzles.</p>

================
File: src/app/syllogimous/pages/tutorial/binary/binary.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-binary",
    templateUrl: "./binary.component.html",
    styleUrls: ["./binary.component.css"]
})
export class TutorialBinaryComponent {}

================
File: src/app/syllogimous/pages/tutorial/comparison-chronological/comparison-chronological.component.html
================
<h2>How to Play Comparison Chronological</h2>
<p>Comparison chronological questions challenge your ability to determine the correct order of events or objects based on the given premises. Here's how you can navigate these puzzles:</p>

<h3>Step 1</h3>
<p>Each question starts with a series of statements that describe the relative order of items. For example:</p>
<ul>
    <li><strong>Premise 1:</strong> Knife is after Shoulder</li>
    <li><strong>Premise 2:</strong> Knife is before Hostel</li>
    <li><strong>Premise 3:</strong> Desktop is after Hostel</li>
    <li><strong>Premise 4:</strong> Knife is after Desktop</li>
</ul>
<p>These premises provide the necessary information to establish the chronological sequence of the items.</p>

<h3>Step 2</h3>
<p>You need to mentally or visually map out the order of the items based on the premises. Here's how you can break it down:</p>
<ol>
    <li><strong>Identify Direct Relationships:</strong></li>
    <ul>
        <li>"Knife is after Shoulder" means Shoulder comes before Knife.</li>
        <li>"Knife is before Hostel" means Knife comes before Hostel.</li>
    </ul>
    <li><strong>Cross-reference with Other Premises:</strong></li>
    <ul>
        <li>"Desktop is after Hostel" places Desktop after Hostel.</li>
        <li>"Knife is after Desktop" implies that Knife comes after Desktop.</li>
    </ul>
</ol>

<h3>Step 3</h3>
<p>Using the premises, arrange the items in the correct sequence:</p>
<ul>
    <li><strong>From Premise 2 and Premise 3:</strong> Shoulder → Knife → Hostel → Desktop.</li>
    <li>However, Premise 4 contradicts Premise 2 and Premise 3. Premise 4 says "Knife is after Desktop," which cannot logically fit into the sequence established by the previous premises.</li>
</ul>
<p>This discrepancy shows that there's an inconsistency, indicating that not all premises can be true simultaneously.</p>

<h3>Step 4</h3>
<p>Based on your analysis, you may be asked to verify a statement like "Is the Knife correctly positioned after the Desktop?" Given the contradictory premises, you would determine that this sequence is <strong>False</strong>.</p>
<p>After selecting <strong>True</strong> or <strong>False</strong>, you'll receive feedback, allowing you to see if your reasoning was correct.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Visualize the sequence:</strong> Drawing a timeline or diagram can help you more easily identify the correct order.</li>
    <li><strong>Watch for contradictions:</strong> Some questions are designed to include contradictory premises to test your attention to detail.</li>
</ul>
<p>By following these steps, you can confidently tackle comparison chronological questions, improving your ability to logically order events or items based on given information!</p>

================
File: src/app/syllogimous/pages/tutorial/comparison-chronological/comparison-chronological.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-comparison-chronological",
    templateUrl: "./comparison-chronological.component.html",
    styleUrls: ["./comparison-chronological.component.css"]
})
export class TutorialComparisonChronologicalComponent {}

================
File: src/app/syllogimous/pages/tutorial/comparison-numerical/comparison-numerical.component.html
================
<h2>How to Play Comparison Numerical</h2>
    
<h3>Step 1</h3>
<p>Each question presents you with a set of comparisons between different items. For example:</p>
<ul>
    <li><strong>Comparison 1:</strong> Sea is less than Pyramid</li>
    <li><strong>Comparison 2:</strong> Sea is more than Turtle</li>
    <li><strong>Comparison 3:</strong> Wrist is less than Turtle</li>
    <li><strong>Comparison 4:</strong> Pyramid is more than Turtle</li>
</ul>
<p>These comparisons provide the relational framework needed to evaluate a conclusion.</p>

<h3>Step 2</h3>
<p>The key to solving these questions is understanding how the items relate to each other based on the given comparisons. Let’s break down the example:</p>
<ul>
    <li><strong>Sea &lt; Pyramid:</strong> The Sea is smaller (or less) than the Pyramid.</li>
    <li><strong>Sea &gt; Turtle:</strong> The Sea is larger (or more) than the Turtle.</li>
    <li><strong>Wrist &lt; Turtle:</strong> The Wrist is smaller (or less) than the Turtle.</li>
    <li><strong>Pyramid &gt; Turtle:</strong> The Pyramid is larger (or more) than the Turtle.</li>
</ul>

<h3>Step 3</h3>
<p>You will need to determine if a new comparison or conclusion is logically valid based on the relationships given. For example:</p>
<p><strong>Conclusion:</strong> "Wrist is less than Sea."</p>
<p>To evaluate this conclusion, consider the chain of relationships:</p>
<p>Since Sea is more than Turtle and Wrist is less than Turtle, it logically follows that Wrist is less than Sea.</p>

<h3>Step 4</h3>
<p>After analyzing the relationships:</p>
<ul>
    <li>If the conclusion logically follows from the given comparisons, click the <strong>True</strong> button.</li>
    <li>If the conclusion does not logically follow, click the <strong>False</strong> button.</li>
</ul>
<p>For the example provided:</p>
<p><strong>Conclusion:</strong> "Wrist is less than Sea."</p>
<p>Based on the comparisons (Wrist &lt; Turtle &lt; Sea), this conclusion would be <strong>True</strong>.</p>
<p>After submitting your answer, the game will provide feedback on whether your choice was correct, helping you learn and improve your ability to evaluate numerical comparisons.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Map it out:</strong> Sometimes it helps to visualize the relationships in a linear order or hierarchy.</li>
    <li><strong>Consider all premises:</strong> Ensure that your conclusion is consistent with all the given comparisons.</li>
    <li><strong>Practice and patience:</strong> With practice, you'll improve your ability to quickly analyze and draw accurate conclusions.</li>
</ul>

================
File: src/app/syllogimous/pages/tutorial/comparison-numerical/comparison-numerical.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-comparison-numerical",
    templateUrl: "./comparison-numerical.component.html",
    styleUrls: ["./comparison-numerical.component.css"]
})
export class TutorialComparisonNumericalComponent {}

================
File: src/app/syllogimous/pages/tutorial/direction/direction.component.html
================
<h2>How to Play Direction</h2>

<h3>Step 1</h3>
<p>Each question will present a series of directional relationships. These premises describe where one object is located in relation to another. For example:</p>
<ul>
    <li><strong>Premise 1:</strong> Jewelry is at East of Color</li>
    <li><strong>Premise 2:</strong> Tail is at West of Milk</li>
    <li><strong>Premise 3:</strong> Color is at South-East of Tail</li>
    <li><strong>Premise 4:</strong> Milk is at South-East of Jewelry</li>
</ul>
<p>These premises establish the spatial relationships between the different objects.</p>

<h3>Step 2</h3>
<p>To solve the puzzle, you need to mentally (or physically) map out the positions of each object based on the given premises.</p>
<ol>
    <li><strong>Start with a base reference:</strong> Choose one object to start with. For example, place "Tail" in your mental map or on paper.</li>
    <li><strong>Place the related objects:</strong> According to the premises:
        <ul>
            <li>If "Tail is at West of Milk," then place "Milk" to the right (east) of "Tail."</li>
            <li>"Color is at South-East of Tail," so "Color" should be below and to the right of "Tail."</li>
            <li>"Jewelry is at East of Color," so "Jewelry" should be directly to the right of "Color."</li>
            <li>"Milk is at South-East of Jewelry," meaning "Milk" is positioned below and to the right of "Jewelry."</li>
        </ul>
    </li>
</ol>

<h3>Step 3</h3>
<p>Once you have a clear map of the objects, check the consistency of their relationships according to the premises. For example, confirm that "Milk" is indeed south-east of "Jewelry" and that "Jewelry" is correctly placed east of "Color."</p>

<h3>Step 4</h3>
<p>Based on the spatial arrangement you've mapped out, you might be asked to determine the validity of a specific directional statement. If the question provides a new statement like "Jewelry is north of Tail," you would compare it against your mental map.</p>
<p>If your map shows that "Jewelry" is not north of "Tail" but rather to its east, you would click <strong>False</strong>. If the statement matches your map, click <strong>True</strong>.</p>
<p>After selecting either <strong>True</strong> or <strong>False</strong>, the game will indicate whether your choice was correct. This helps reinforce your understanding of spatial relationships and improve your problem-solving skills.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Draw it out:</strong> If you find it challenging to visualize the positions, draw them on paper to keep track of the objects and their relationships.</li>
    <li><strong>Double-check your map:</strong> Before making your final choice, review the entire map to ensure accuracy.</li>
</ul>

<p>By following these steps, you'll enhance your ability to solve direction-type questions, making you better at spatial reasoning and logical thinking.</p>

================
File: src/app/syllogimous/pages/tutorial/direction/direction.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-direction",
    templateUrl: "./direction.component.html",
    styleUrls: ["./direction.component.css"]
})
export class TutorialDirectionComponent {}

================
File: src/app/syllogimous/pages/tutorial/direction3D/direction3D.component.html
================
<h2>How to Play Direction3D</h2>
<p>Direction3D questions are spatial reasoning puzzles where you must determine the relative positions of different objects in a 3D space based on given statements. Here’s how you can play:</p>

<h3>Step 1</h3>
<p>Each Direction3D question presents a set of spatial relationships between different objects. For example:</p>
<ul>
    <li><strong>Statement 1:</strong> Temple is Above and West of Luggage</li>
    <li><strong>Statement 2:</strong> Luggage is South of Governor</li>
    <li><strong>Statement 3:</strong> Hotel is North-East of Temple</li>
    <li><strong>Statement 4:</strong> Governor is Below of Hotel</li>
</ul>
<p>These statements describe the positions of objects relative to one another in three-dimensional space.</p>

<h3>Step 2</h3>
<p>To solve the puzzle, try to mentally visualize or sketch the positions of the objects based on the given statements:</p>
<ul>
    <li><strong>Temple</strong> is positioned <strong>Above</strong> and <strong>West</strong> of <strong>Luggage</strong>.</li>
    <li><strong>Luggage</strong> is positioned <strong>South</strong> of <strong>Governor</strong>.</li>
    <li><strong>Hotel</strong> is positioned <strong>North-East</strong> of <strong>Temple</strong>.</li>
    <li><strong>Governor</strong> is positioned <strong>Below</strong> <strong>Hotel</strong>.</li>
</ul>

<h3>Step 3</h3>
<p>After understanding each object's relative position, you may be asked to verify a specific relationship between two or more objects. For example:</p>
<p><em>Question:</em> "Is the Hotel above the Governor?"</p>
<p>Based on the given statements:</p>
<ul>
    <li><strong>Hotel</strong> is North-East of <strong>Temple</strong>, and <strong>Governor</strong> is Below <strong>Hotel</strong>.</li>
    <li>Therefore, <strong>Hotel</strong> should indeed be above <strong>Governor</strong>.</li>
</ul>

<h3>Step 4</h3>
<p>Based on your analysis, click the <strong>True</strong> button if you believe the given relationship is correct or the <strong>False</strong> button if you think it is not.</p>
<p>For instance:</p>
<p>If the game asks if "Hotel is above the Governor," you would select <strong>True</strong> based on the reasoning above.</p>
<p>After making your choice, the game will confirm whether you were correct or not, helping you refine your spatial reasoning skills.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<p><strong>Use a mental map:</strong> Visualize or draw a simple sketch to track the positions of each object.</p>
<p><strong>Consider all dimensions:</strong> Remember that positions can change along multiple axes (north-south, east-west, above-below).</p>

================
File: src/app/syllogimous/pages/tutorial/direction3D/direction3D.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-direction3D",
    templateUrl: "./direction3D.component.html",
    styleUrls: ["./direction3D.component.css"]
})
export class TutorialDirection3DComponent {}

================
File: src/app/syllogimous/pages/tutorial/direction4D/direction4D.component.html
================
<h2>How to Play Direction4D</h2>
<p>Direction4D is a complex logical puzzle where you need to consider both spatial directions and the timing of events to determine the relationship between different entities. Here's how you can approach these questions:</p>

<h3>Step 1</h3>
<p>Each question provides a series of statements that describe the positions of different entities relative to each other in both space and time. For example:</p>
<ul>
    <li><strong>Statement 1:</strong> Taxi was Below and West of Dentist</li>
    <li><strong>Statement 2:</strong> Dentist is North of Woman</li>
    <li><strong>Statement 3:</strong> Woman was Above and South-West of Shark</li>
    <li><strong>Statement 4:</strong> Shark was West of Taxi</li>
</ul>
<p>These statements describe spatial relationships with directional terms (e.g., West, North, Above) and include temporal aspects (e.g., "was").</p>

<h3>Step 2</h3>
<p>To solve the puzzle, you need to mentally map out the positions of the entities. Start by sketching or imagining their relative positions:</p>
<ul>
    <li><strong>Taxi and Dentist:</strong> The Taxi is Below and West of the Dentist. This places the Dentist somewhere North-East of the Taxi.</li>
    <li><strong>Dentist and Woman:</strong> The Dentist is North of the Woman. So, the Woman is directly South of the Dentist.</li>
    <li><strong>Woman and Shark:</strong> The Woman was Above and South-West of the Shark. This places the Shark below and slightly North-East of the Woman.</li>
    <li><strong>Shark and Taxi:</strong> The Shark was West of the Taxi. This puts the Taxi East of the Shark.</li>
</ul>

<h3>Step 3</h3>
<p>The temporal phrases like "was" indicate that a subject should be considered in its past position, without any change in spatial location over time. Consider this when assessing the overall positions:</p>
<ul>
    <li>The use of "was" suggests that positions may not be current but were true at a specific time in the past.</li>
</ul>

<h3>Step 4</h3>
<p>Now, evaluate the conclusion or question based on the relationships you have mapped out. For example, if asked:</p>
<ul>
    <li><strong>Conclusion:</strong> "Is it possible that the Shark is now North of the Dentist?"</li>
</ul>
<p>To answer:</p>
<ul>
    <li><strong>Analyze:</strong> Given the initial positions, the Shark was to the West of the Taxi, and the Taxi was Below and West of the Dentist. The Dentist is North of the Woman, and the Woman was Above and South-West of the Shark.</li>
    <li><strong>Evaluate:</strong> It’s unlikely that the Shark could be North of the Dentist based on these relative positions.</li>
</ul>

<h3>Step 5</h3>
<p>Based on your analysis, decide whether the given conclusion is True or False. Click the <strong>True</strong> button if the conclusion logically follows, or <strong>False</strong> if it does not.</p>
<p>In this case, the conclusion "Shark is now North of Dentist" would likely be <strong>False</strong> based on the original statements.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Draw a diagram:</strong> If the relationships are complex, drawing them out can help clarify.</li>
    <li><strong>Consider the temporal aspect:</strong> Remember that "was" implies a temporal relationship without affecting the spatial one; therefore, the position should be considered as if it hasn't changed.</li>
    <li><strong>Double-check relationships:</strong> Ensure that all entities’ positions align logically with each other before making your decision.</li>
</ul>

<p>By carefully analyzing both the spatial and temporal elements, you can master Direction4D questions and improve your multidimensional reasoning skills!</p>

================
File: src/app/syllogimous/pages/tutorial/direction4D/direction4D.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-direction4D",
    templateUrl: "./direction4D.component.html",
    styleUrls: ["./direction4D.component.css"]
})
export class TutorialDirection4DComponent {}

================
File: src/app/syllogimous/pages/tutorial/distinction/distinction.component.html
================
<h2>How to Play Distinction</h2>
<p>Distinction-type questions challenge your ability to analyze relationships between different items based on whether they are the same or opposite. Here’s a guide on how to approach these questions:</p>

<h3>Step 1</h3>
<p>Distinction questions begin with a set of premises that define the relationships between various items. These premises will tell you whether items are the same or opposite. For example:</p>
<ul>
    <li><strong>Premise 1:</strong> Mango is the same as Glass</li>
    <li><strong>Premise 2:</strong> Herbs is the same as Mango</li>
    <li><strong>Premise 3:</strong> Glass is the same as Shower</li>
    <li><strong>Premise 4:</strong> Herbs is opposite of Shower</li>
</ul>
<p>These premises set up the relationships you need to consider.</p>

<h3>Step 2</h3>
<p>Your goal is to understand how the items relate to each other based on the provided premises. Follow these steps:</p>
<ul>
    <li><strong>Identify direct relationships:</strong> Start by connecting items that are directly related. For example:
        <ul>
            <li>"Mango is the same as Glass"</li>
            <li>"Herbs is the same as Mango"</li>
            <li>"Glass is the same as Shower"</li>
        </ul>
        This means Mango, Glass, and Shower are all the same. Since "Herbs is the same as Mango," Herbs should also be the same as Glass and Shower.
    </li>
    <li><strong>Consider opposing relationships:</strong> Next, look at the premise that introduces an opposition:
        <ul>
            <li>"Herbs is opposite of Shower"</li>
        </ul>
        Here, despite Herbs being the same as Mango, Glass, and Shower, it’s also stated to be opposite to Shower.
    </li>
</ul>

<h3>Step 3</h3>
<p>Based on your analysis, the game might ask you to evaluate a statement like:</p>
<p><strong>Conclusion:</strong> "Mango is opposite of Shower."</p>
<p>You need to decide if this conclusion logically follows from the premises. Since Mango is the same as Shower (from the premises), the conclusion "Mango is opposite of Shower" would be <strong>False</strong>.</p>

<h3>Step 4</h3>
<p>After your analysis, select <strong>True</strong> if you believe the conclusion follows from the premises or <strong>False</strong> if it does not.</p>
<p>In our example, you would select <strong>False</strong> because Mango, Glass, and Shower are all stated to be the same, making it impossible for Mango to be opposite of Shower.</p>
<p>The game will provide immediate feedback, letting you know whether your choice was correct. Use this feedback to improve your understanding of how distinctions are made in logical reasoning.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Look for contradictions:</strong> If an item is stated to be the same as one and opposite of another, look for possible contradictions to determine the correct conclusion.</li>
    <li><strong>Map relationships:</strong> Visually or mentally map out the relationships to better understand how each item connects.</li>
</ul>

<p>By following this method, you'll be well-prepared to tackle distinction-type questions, enhancing your ability to navigate complex logical relationships.</p>

================
File: src/app/syllogimous/pages/tutorial/distinction/distinction.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-distinction",
    templateUrl: "./distinction.component.html",
    styleUrls: ["./distinction.component.css"]
})
export class TutorialDistinctionComponent {}

================
File: src/app/syllogimous/pages/tutorial/syllogism/syllogism.component.html
================
<h2>How to Play Syllogism</h2>
<p>Syllogism-type questions are logical puzzles where you must determine if a conclusion logically follows from a set of given premises. Here’s how to play:</p>

<h3>Step 1</h3>
<p>Each syllogism question starts with a set of premises. A premise is a statement that you assume to be true. For example:</p>
<ul>
    <li><strong>Premise 1:</strong> Some Planet is Soup</li>
    <li><strong>Premise 2:</strong> No Freezer is Turtle</li>
    <li><strong>Premise 3:</strong> No Freezer is Planet</li>
    <li><strong>Premise 4:</strong> All Turtle is Planet</li>
</ul>
<p>These premises form the basis of the logic puzzle.</p>

<h3>Step 2</h3>
<p>The game will present a conclusion that you must evaluate based on the premises. The conclusion might not always be explicitly provided; instead, you may infer it based on the premises. For example, you might be asked to evaluate the following conclusion:</p>
<p><strong>Conclusion:</strong> "Some Freezer is Soup."</p>

<h3>Step 3</h3>
<p>To determine whether the conclusion is true or false, follow these steps:</p>
<ol>
    <li><strong>Examine the relationships</strong> defined by the premises. For instance, "No Freezer is Planet" and "No Freezer is Turtle" suggest that Freezer is entirely separate from both Planet and Turtle.</li>
    <li><strong>Check consistency</strong> with the conclusion. In the example conclusion "Some Freezer is Soup," see if this is logically possible given the relationships in the premises.</li>
</ol>

<h3>Step 4</h3>
<p>Once you’ve analyzed the premises and the conclusion, click the <strong>True</strong> button if you believe the conclusion logically follows from the premises, or the <strong>False</strong> button if it does not.</p>
<p>For example, based on the premises provided:</p>
<ul>
    <li>Since "No Freezer is Planet" and "No Freezer is Turtle," and "All Turtle is Planet," we can deduce that a Freezer cannot be Soup if Soup is a Planet or Turtle. Thus, the conclusion "Some Freezer is Soup" would be <strong>False</strong>.</li>
</ul>
<p>After you make your choice, the game will inform you whether you were correct or incorrect, helping you learn and improve your logical reasoning skills.</p>

<h3>The <span class="is-negated">Negation</span> Cue</h3>
<p>Whenever you encounter a phrase highlighted in <span class="is-negated">red</span>, it's an indication that you need to think inversely about the information presented.</p>

<h3>Tips for Success</h3>
<ul>
    <li><strong>Take your time:</strong> Carefully read and analyze each premise before making a decision.</li>
    <li><strong>Practice makes perfect:</strong> The more you play, the better you'll get at recognizing valid conclusions.</li>
</ul>

<p>By following these steps, you’ll be able to master syllogism questions and sharpen your logical reasoning abilities!</p>

================
File: src/app/syllogimous/pages/tutorial/syllogism/syllogism.component.ts
================
import { Component } from "@angular/core";

@Component({
    selector: "app-tutorial-syllogism",
    templateUrl: "./syllogism.component.html",
    styleUrls: ["./syllogism.component.css"]
})
export class TutorialSyllogismComponent {}

================
File: src/app/syllogimous/pages/tutorial/tutorial.component.html
================
<app-card>
    <div body>
        <router-outlet class="d-none"></router-outlet>
    </div>

    <div footer class="playcard-toolbar">
        <div>
            <div class="form-check">
                <input #dontShowAnymore class="form-check-input" type="checkbox" value="" id="dontShowAnymore">
                <label class="form-check-label" for="dontShowAnymore">
                    Don't show anymore
                </label>
            </div>
        </div>
        <div>
            <button
                class="btn btn-outline-primary"
                (click)="sylSrv.skipTutorial(dontShowAnymore.checked)"
            >Skip Tutorial</button>
        </div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/tutorial/tutorial.component.ts
================
import { Component } from '@angular/core';
import { SyllogimousService } from '../../services/syllogimous.service';

@Component({
    selector: 'app-tutorial',
    templateUrl: './tutorial.component.html',
    styleUrls: ['./tutorial.component.css']
})
export class TutorialComponent {
    constructor(
        public sylSrv: SyllogimousService
    ) { }
}

================
File: src/app/syllogimous/pages/tutorials/tutorials.component.css
================
[body] {
    position: absolute;
    width: 100%;
    max-height: 100%;
    overflow: auto;
}

[body] ::ng-deep .accordion-header:has(button[aria-expanded="true"]) {
    position: sticky;
    top: 0;
}

[body] ::ng-deep .accordion-item,
[body] ::ng-deep .accordion-button {
    border-left: none;
    border-right: none;
    border-radius: 0 !important;
}

[body] ::ng-deep .accordion-item:not(:last-child) {
    border-bottom: 1px solid #eee;
}

================
File: src/app/syllogimous/pages/tutorials/tutorials.component.html
================
<app-card>
    <div body>
        <div class="text-center" *ngIf="!questions.length">
            <h3 class="mb-3">Play to discover question types</h3>
            <button class="btn btn-lg btn-primary" (click)="sylSrv.start()">Press to Play</button>
        </div>
        
        <ngb-accordion #acc="ngbAccordion" [closeOthers]="true" *ngIf="questions.length">
            <ngb-panel title="Analogy" *ngIf="seenQs['Analogy']">
                <ng-template ngbPanelContent>
                    <app-tutorial-analogy></app-tutorial-analogy>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Binary" *ngIf="seenQs['Binary']">
                <ng-template ngbPanelContent>
                    <app-tutorial-binary></app-tutorial-binary>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Comparison Chronological" *ngIf="seenQs['Comparison Chronological']">
                <ng-template ngbPanelContent>
                    <app-tutorial-comparison-chronological></app-tutorial-comparison-chronological>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Comparison Numerical" *ngIf="seenQs['Comparison Numerical']">
                <ng-template ngbPanelContent>
                    <app-tutorial-comparison-numerical></app-tutorial-comparison-numerical>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Direction" *ngIf="seenQs['Direction']">
                <ng-template ngbPanelContent>
                    <app-tutorial-direction></app-tutorial-direction>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Direction 3D" *ngIf="seenQs['Direction 3D']">
                <ng-template ngbPanelContent>
                    <app-tutorial-direction3D></app-tutorial-direction3D>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Direction 4D" *ngIf="seenQs['Direction 4D']">
                <ng-template ngbPanelContent>
                    <app-tutorial-direction4D></app-tutorial-direction4D>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Distinction" *ngIf="seenQs['Distinction']">
                <ng-template ngbPanelContent>
                    <app-tutorial-distinction></app-tutorial-distinction>
                </ng-template>
            </ngb-panel>
        
            <ngb-panel title="Syllogism" *ngIf="seenQs['Syllogism']">
                <ng-template ngbPanelContent>
                    <app-tutorial-syllogism></app-tutorial-syllogism>
                </ng-template>
            </ngb-panel>
        </ngb-accordion>
    </div>

    <div footer class="playcard-toolbar">
        <div>
            <button
                class="btn btn-outline-primary"
                (click)="router.navigate([EnumScreens.Start])"
            >
                <i class="bi bi-arrow-left"></i> Go to Start
            </button>
        </div>
    </div>
</app-card>

================
File: src/app/syllogimous/pages/tutorials/tutorials.component.ts
================
import { Component } from '@angular/core';
import { Question } from '../../models/question.models';
import { SyllogimousService } from '../../services/syllogimous.service';
import { LS_HISTORY } from '../../constants/local-storage.constants';
import { EnumScreens } from '../../models/syllogimous.models';
import { Router } from '@angular/router';

@Component({
    selector: 'app-tutorials',
    templateUrl: './tutorials.component.html',
    styleUrls: ['./tutorials.component.css']
})
export class TutorialsComponent {
    EnumScreens = EnumScreens;
    questions: Question[] = [];
    seenQs: Record<string, boolean> = {};

    constructor(
        public sylSrv: SyllogimousService,
        public router: Router
    ) { }

    ngOnInit() {
        const history = localStorage.getItem(LS_HISTORY);
        if (history) {
            this.questions = JSON.parse(history).reverse();
            this.seenQs = this.questions.reduce((acc, curr) => (acc[curr.type] = true, acc), {} as any);
        }
    }
}

================
File: src/app/syllogimous/services/stats.service.ts
================
import { Injectable } from "@angular/core";
import { Question } from "../models/question.models";
import { SyllogimousService } from "./syllogimous.service";

export interface TypeBasedPromiseLengthStats {
    sum: number;
    count: number;
    fastest: number;
    slowest: number;
    correct: number;
    incorrect: number;
    timeout: number;
    last10Sum: number;
    last10Count: number;
    last10Fastest: number;
    last10Slowest: number;
    last10Correct: number;
    last10Incorrect: number;
    last10Timeout: number;
}

@Injectable({
    providedIn: "root"
})
export class StatsService {
    questions: Question[] = [];
    types: string[] = [];
    typeBasedStats: Record<string, { type: string, completed: number, accuracy: number, stats: Record<string, TypeBasedPromiseLengthStats> }> = {};

    constructor(
        public sylSrv: SyllogimousService
    ) { }

    ngOnInit() {
        this.calcStats();
    }

    calcStats() {
        this.questions = this.sylSrv.questionsFromLS;

        this.types = [ ...new Set(this.questions.map(q => q.type)) ];
        this.typeBasedStats = this.types.reduce((acc, curr) => (acc[curr] = { type: "", completed: 0, accuracy: 0, stats: {} }, acc), {} as Record<string, any>);
        this.types
            .map(type => this.questions.filter(q => q.type === type))
            .forEach((questions, idx) => {
                const type = this.types[idx];

                this.typeBasedStats[type].type = type;
                this.typeBasedStats[type].completed = questions.length;
                this.typeBasedStats[type].accuracy = questions.length && (questions.filter(q => q.userAnswer === q.isValid).length / questions.length);

                [...questions].reverse().forEach((q, i) => {
                    const ps = q.premises.length;
                    this.typeBasedStats[type].stats[ps] = this.typeBasedStats[type].stats[ps] || {
                        sum: 0,
                        count: 0,
                        fastest: 0,
                        slowest: 0,
                        correct: 0,
                        incorrect: 0,
                        timeout: 0,
                        last10Sum: 0,
                        last10Count: 0,
                        last10Fastest: 0,
                        last10Slowest: 0,
                        last10Correct: 0,
                        last10Incorrect: 0,
                        last10Timeout: 0,
                    };
        
                    const dt = q.answeredAt - q.createdAt;
        
                    this.typeBasedStats[type].stats[ps].sum += dt;
                    this.typeBasedStats[type].stats[ps].count += 1;

                    if (q.userAnswer == undefined) {
                        this.typeBasedStats[type].stats[ps].timeout++;
                    } else if (q.userAnswer === q.isValid) {
                        this.typeBasedStats[type].stats[ps].correct++;
                    } else {
                        this.typeBasedStats[type].stats[ps].incorrect++;
                    }
        
                    if (q.userAnswer !== undefined) {
                        if (this.typeBasedStats[type].stats[ps].fastest === 0 || dt < this.typeBasedStats[type].stats[ps].fastest) {
                            this.typeBasedStats[type].stats[ps].fastest = dt;
                        }
                        if (this.typeBasedStats[type].stats[ps].slowest === 0 || dt > this.typeBasedStats[type].stats[ps].slowest) {
                            this.typeBasedStats[type].stats[ps].slowest = dt;
                        }
                    }

                    // Calculate last 10 questions stats
                    if (i < 10) {
                        this.typeBasedStats[type].stats[ps].last10Sum += dt;
                        this.typeBasedStats[type].stats[ps].last10Count += 1;

                        if (q.userAnswer == undefined) {
                            this.typeBasedStats[type].stats[ps].last10Timeout++;
                        } else if (q.userAnswer === q.isValid) {
                            this.typeBasedStats[type].stats[ps].last10Correct++;
                        } else {
                            this.typeBasedStats[type].stats[ps].last10Incorrect++;
                        }
            
                        if (q.userAnswer !== undefined) {
                            if (this.typeBasedStats[type].stats[ps].last10Fastest === 0 || dt < this.typeBasedStats[type].stats[ps].last10Fastest) {
                                this.typeBasedStats[type].stats[ps].last10Fastest = dt;
                            }
                            if (this.typeBasedStats[type].stats[ps].last10Slowest === 0 || dt > this.typeBasedStats[type].stats[ps].last10Slowest) {
                                this.typeBasedStats[type].stats[ps].last10Slowest = dt;
                            }
                        }
                    }
                });
            });

        console.log("stats", { types: this.types, typeBasedStats: this.typeBasedStats });
    }
}

================
File: src/app/syllogimous/services/syllogimous.service.ts
================
import { Injectable } from "@angular/core";
import { EnumQuestionType, Question } from "../models/question.models";
import { coinFlip, findDirection, findDirection3D, findDirection4D, getRandomRuleInvalid, getRandomRuleValid, getRandomSymbols, getRelation, getSyllogism, getSymbols, isPremiseLikeConclusion, makeMetaRelations, pickUniqueItems, shuffle } from "../utils/engine.utils";
import { DIRECTION_COORDS, DIRECTION_COORDS_3D, DIRECTION_NAMES, DIRECTION_NAMES_3D, DIRECTION_NAMES_3D_INVERSE, DIRECTION_NAMES_INVERSE, TIME_NAMES } from "../constants/engine.constants";
import { EnumScreens, EnumTiers } from "../models/syllogimous.models";
import { TIER_SCORE_ADJUSTMENTS, TIER_SCORE_RANGES, TIER_SETTINGS } from "../constants/syllogimous.constants";
import { LS_DONT_SHOW, LS_HISTORY, LS_SCORE } from "../constants/local-storage.constants";
import { NgbModal } from "@ng-bootstrap/ng-bootstrap";
import { ModalLevelChangeComponent } from "../components/modal-level-change/modal-level-change.component";
import { Router } from "@angular/router";

@Injectable({
    providedIn: "root"
})
export class SyllogimousService {
    _score = 0;
    history: Question[] = [];
    question = this.createSyllogism(2);

    get score() {
        return this._score;
    }

    set score(value: number) {
        this._score = value;
        localStorage.setItem(LS_SCORE, JSON.stringify(value));
    }

    get tier() {
        for (const tier of Object.values(EnumTiers)) {
            const range = TIER_SCORE_RANGES[tier];
            if (this.score >= range.minScore && this.score <= range.maxScore) {
                return tier as EnumTiers;
            }
        }
        return EnumTiers.Adept;
    }

    get settings() {
        return TIER_SETTINGS[this.tier];
    }

    get questionsFromLS() {
        let questions: Question[] = [];
        const history = localStorage.getItem(LS_HISTORY);
        if (history) {
            questions = JSON.parse(history).reverse();
        }
        return questions;
    }

    constructor(
        private modalService: NgbModal,
        private router: Router
    ) {
        this.loadScore();
        this.loadHistory();

        if (!localStorage.getItem(LS_DONT_SHOW + EnumScreens.Intro)) {
            this.router.navigate([EnumScreens.Intro]);
        } else {
            this.router.navigate([EnumScreens.Start]);
        }
    }

    loadScore() {
        const lsScore = localStorage.getItem(LS_SCORE);
        if (lsScore) {
            this.score = JSON.parse(lsScore);
        }
    }

    loadHistory() {
        const lsHistory = localStorage.getItem(LS_HISTORY);
        if (lsHistory) {
            this.history = JSON.parse(lsHistory);
        }
    }

    pushIntoHistory(question: Question) {
        this.history = [ ...this.history, question ];
        localStorage.setItem(LS_HISTORY, JSON.stringify(this.history));
    }

    createQuestion() {
        const choices = [];
        if (this.settings.distinction[0]) {
            choices.push(() => this.createDistinction(this.settings.distinction[1]));
        }
        if (this.settings.comparisonNumerical[0]) {
            choices.push(() => this.createComparison(this.settings.comparisonNumerical[1], EnumQuestionType.ComparisonNumerical));
        }
        if (this.settings.comparisonChronological[0]) {
            choices.push(() => this.createComparison(this.settings.comparisonChronological[1], EnumQuestionType.ComparisonChronological));
        }
        if (this.settings.syllogism[0]) {
            choices.push(() => this.createSyllogism(this.settings.syllogism[1]));
        }
        if (this.settings.direction[0]) {
            choices.push(() => this.createDirection(this.settings.direction[1]));
        }
        if (this.settings.direction3D[0]) {
            choices.push(() => this.createDirection3D(this.settings.direction3D[1]));
        }
        if (this.settings.direction4D[0]) {
            choices.push(() => this.createDirection4D(this.settings.direction4D[1]));
        }
        if (this.settings.analogy[0]) {
            choices.push(() => this.createAnalogy(this.settings.analogy[1]));
        }
        if (this.settings.binary[0]) {
            choices.push(() => this.createBinary(this.settings.binary[1]));
        }

        const randomQuestion = pickUniqueItems(choices, 1).picked[0]();
        console.log("createQuestion()", randomQuestion);
        this.question = randomQuestion!;
    }

    skipIntro(dontShowAnymore: boolean) {
        if (dontShowAnymore) {
            localStorage.setItem(LS_DONT_SHOW + EnumScreens.Intro, "1")
        }
        this.router.navigate([EnumScreens.Start]);
    }

    start() {
        this.createQuestion();
        if (!localStorage.getItem(LS_DONT_SHOW + this.question.type)) {
            this.router.navigate([EnumScreens.Tutorial, this.question.type]);
        } else {
            this.router.navigate([EnumScreens.Game]);
        }
    }

    skipTutorial(dontShowAnymore: boolean) {
        if (dontShowAnymore) {
            localStorage.setItem(LS_DONT_SHOW + this.question.type, "1")
        }
        this.router.navigate([EnumScreens.Game]);
    }

    checkQuestion(value?: boolean) {
        this.question.userAnswer = value;
        this.question.answeredAt = Date.now();

        const currTier = this.tier;

        let ds = 0;
        if (this.question.userAnswer === this.question.isValid) {
            this.score += TIER_SCORE_ADJUSTMENTS[this.tier].increment;
            ds += 1;
        } else {
            this.score = Math.max(0, this.score - TIER_SCORE_ADJUSTMENTS[this.tier].decrement);
            if (this.score !== 0) {
                ds -= 1;
            }
        }

        const nextTier = this.tier;

        // Level up/down
        if (currTier !== nextTier) {
            const modalRef = this.modalService.open(ModalLevelChangeComponent, { centered: true });
            if (ds > 0) { // level up
                modalRef.componentInstance.title = "Congratulations, You've Leveled Up!";
                modalRef.componentInstance.content = "Your hard work is paying off.\nKeep going to unlock more features and rewards!";
            } else if (ds < 0) { // level down
                modalRef.componentInstance.title = "Level Down - Let's Regroup!";
                modalRef.componentInstance.content = "Take this as a learning step.\nRefocus your efforts and you’ll be back on top in no time!";
            }
        }

        this.pushIntoHistory(this.question);
        this.router.navigate([EnumScreens.Feedback]);
        setTimeout(() => this.router.navigate([EnumScreens.Start]), 750);
    }

    createSyllogism(length: number) {
        if (length < 2) throw Error("Needs at least 2 premises.");

        length++;
    
        const question = new Question(EnumQuestionType.Syllogism);
        question.isValid = coinFlip();

        do {
            question.rule = question.isValid ? getRandomRuleValid() : getRandomRuleInvalid();
            question.bucket = getRandomSymbols(this.settings, length);
            question.premises = [];

            [
                question.premises[0],
                question.premises[1],
                question.conclusion
            ] = getSyllogism(
                this.settings,
                question.bucket[0],
                question.bucket[1],
                question.bucket[2],
                question.isValid ? getRandomRuleValid() : getRandomRuleInvalid()
            );
        } while(isPremiseLikeConclusion(question.premises, question.conclusion));

        for (let i = 3; i < length; i++) {
            const rnd = Math.floor(Math.random() * (i - 1));
            const flip = coinFlip();
            const [ p, m ] = flip ? [question.bucket[i], question.bucket[rnd]] : [question.bucket[rnd], question.bucket[i]];
            question.premises.push(getSyllogism(this.settings, "#####", p, m, getRandomRuleInvalid())[0]);
        }
    
        shuffle(question.premises);
    
        return question;
    }

    createDistinction(length: number) {
        if (length < 2) throw Error("Needs at least 2 premises.");

        length++;

        const symbols = getRandomSymbols(this.settings, length);
        const question = new Question(EnumQuestionType.Distinction);

        do {
            const rnd = Math.floor(Math.random() * symbols.length);
            const first = symbols.splice(rnd, 1)
            let prev = first;
            let curr: string[] = [];
    
            question.buckets = [[prev], []];
            let prevBucket = 0;
    
            question.premises = [];

            for (let i = 0; i < length - 1; i++) {
                const rnd = Math.floor(Math.random() * symbols.length);
                curr = symbols.splice(rnd, 1);

                const isSameAs = coinFlip();
                const relation = getRelation(this.settings, EnumQuestionType.Distinction, isSameAs);

                question.premises.push(`<span class="subject">${prev}</span> is ${relation} <span class="subject">${curr}</span>`);

                if (!isSameAs) {
                    prevBucket = (prevBucket + 1) % 2;
                }

                question.buckets[prevBucket].push(curr);
    
                prev = curr;
            }

            makeMetaRelations(this.settings, question, length);

            const isSameAs = coinFlip();
            const relation = getRelation(this.settings, EnumQuestionType.Distinction, isSameAs);

            question.conclusion = `<span class="subject">${first}</span> is ${relation} <span class="subject">${curr}</span>`;
            question.isValid = isSameAs
                ? question.buckets[0].includes(curr)
                : question.buckets[1].includes(curr);
        } while(isPremiseLikeConclusion(question.premises, question.conclusion));
    
        shuffle(question.premises);
    
        return question;
    }

    createComparison(length: number, type: EnumQuestionType.ComparisonNumerical | EnumQuestionType.ComparisonChronological) {
        if (length < 2) throw Error("Needs at least 2 premises.");

        length++;

        const question = new Question(type);

        do {
            question.bucket = getRandomSymbols(this.settings, length);
            question.premises = [];
            const sign = [-1, 1][Math.floor(Math.random() * 2)];

            let next = "";
    
            for (let i = 0; i < length - 1; i++) {
                const curr = question.bucket[i];
                next = question.bucket[i + 1];

                const isMoreOrAfter = coinFlip();
                const [first, last] = ((sign === 1) === isMoreOrAfter) ? [next, curr] : [curr, next];
                const relation = getRelation(this.settings, type, isMoreOrAfter);

                question.premises.push(`<span class="subject">${first}</span> is ${relation} <span class="subject">${last}</span>`);
            }

            makeMetaRelations(this.settings, question, length);

            const a = Math.floor(Math.random() * question.bucket.length);
            let b = Math.floor(Math.random() * question.bucket.length);
            while (a === b) {
                b = Math.floor(Math.random() * question.bucket.length);
            }

            const isMoreOrAfter = coinFlip();
            const relation = getRelation(this.settings, type, isMoreOrAfter);

            question.conclusion = `<span class="subject">${question.bucket[a]}</span> is ${relation} <span class="subject">${question.bucket[b]}</span>`;
            question.isValid = isMoreOrAfter
                ? sign === 1 && a > b || sign === -1 && a < b
                : sign === 1 && a < b || sign === -1 && a > b;
        } while(isPremiseLikeConclusion(question.premises, question.conclusion));
    
        shuffle(question.premises);
    
        return question;
    }

    createDirection(length: number) {
        if (length < 2) throw Error("Needs at least 2 premises.");
        
        length++;
        
        const symbols = getSymbols(this.settings);
        const words = pickUniqueItems(symbols, length).picked;
        const question = new Question(EnumQuestionType.Direction);

        let wordCoordMap: Record<string, [number, number]> = {};
        let conclusionDirection = "";

        while (!conclusionDirection) {
            wordCoordMap = {};
            question.premises = [];
    
            for (let i = 0; i < words.length - 1; i++) {
                const dirIndex = 1 + Math.floor(Math.random()*(DIRECTION_NAMES.length - 1));
                const dirName = DIRECTION_NAMES[dirIndex]!;
                const dirCoord = DIRECTION_COORDS[dirIndex];

                if (i === 0) {
                    wordCoordMap[words[i]] = [0,0];
                }

                wordCoordMap[words[i+1]] = [
                    wordCoordMap[words[i]][0] + dirCoord[0], // x
                    wordCoordMap[words[i]][1] + dirCoord[1]  // y
                ];

                if (this.settings.enableNegation && coinFlip()) {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> is at <span class="is-negated">${(DIRECTION_NAMES_INVERSE as any)[dirName]}</span> of <span class="subject">${words[i]}</span>`);
                } else {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> is at ${dirName} of <span class="subject">${words[i]}</span>`);
                }
            }
    
            conclusionDirection = findDirection(wordCoordMap[words[0]], wordCoordMap[words[length-1]]);
        }

        question.wordCoordMap = wordCoordMap;
        question.isValid = coinFlip();
        const oppositeDirection = findDirection(wordCoordMap[words[length-1]], wordCoordMap[words[0]]);
        const direction = question.isValid ? conclusionDirection : oppositeDirection;

        if (this.settings.enableNegation && coinFlip()) {
            question.conclusion = `<span class="subject">${words[0]}</span> is at <span class="is-negated">${(DIRECTION_NAMES_INVERSE as any)[direction]}</span> of <span class="subject">${words[words.length-1]}</span>`;
        } else {
            question.conclusion = `<span class="subject">${words[0]}</span> is at ${direction} of <span class="subject">${words[words.length-1]}</span>`;
        }
    
        shuffle(question.premises);
        
        return question;
    }

    createDirection3D(length: number) {
        if (length < 2) throw Error("Needs at least 2 premises.");

        length++;
    
        const symbols = getSymbols(this.settings);
        const words = pickUniqueItems(symbols, length).picked;
        const question = new Question(EnumQuestionType.Direction3D);
    
        let wordCoordMap: Record<string, [number, number, number]> = {};
        let conclusionDirection = "";

        while (!conclusionDirection) {
            wordCoordMap = {};
            question.premises = [];
    
            for (let i = 0; i < words.length - 1; i++) {
                const dirIndex = 1 + Math.floor(Math.random() * (DIRECTION_NAMES_3D.length - 1));
                const dirName = DIRECTION_NAMES_3D[dirIndex];
                const dirCoord = DIRECTION_COORDS_3D[dirIndex];

                if (i === 0) {
                    wordCoordMap[words[i]] = [0,0,0];
                }

                wordCoordMap[words[i+1]] = [
                    wordCoordMap[words[i]][0] + dirCoord[0], // x
                    wordCoordMap[words[i]][1] + dirCoord[1], // y
                    wordCoordMap[words[i]][2] + dirCoord[2], // z
                ];

                if (this.settings.enableNegation && coinFlip()) {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> is <span class="is-negated">${(DIRECTION_NAMES_3D_INVERSE as any)[dirName]}</span> of <span class="subject">${words[i]}</span>`);
                } else {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> is ${dirName} of <span class="subject">${words[i]}</span>`);
                }
            }
    
            conclusionDirection = findDirection3D(wordCoordMap[words[0]], wordCoordMap[words[length-1]]);
        }

        question.wordCoordMap = wordCoordMap;
        question.isValid = coinFlip();
        const oppositeDirection = findDirection3D(wordCoordMap[words[length-1]], wordCoordMap[words[0]]);
        const direction = question.isValid ? conclusionDirection : oppositeDirection;

        if (this.settings.enableNegation && coinFlip()) {
            question.conclusion = `<span class="subject">${words[0]}</span> is <span class="is-negated">${(DIRECTION_NAMES_3D_INVERSE as any)[direction]}</span> of <span class="subject">${words[words.length-1]}</span>`;
        } else {
            question.conclusion = `<span class="subject">${words[0]}</span> is ${direction} of <span class="subject">${words[words.length-1]}</span>`;
        }
    
        shuffle(question.premises);
        
        return question;
    }

    createDirection4D(length: number) {
        if (length < 2) throw Error("Needs at least 2 premises.");

        length++;
    
        const symbols = getSymbols(this.settings);
        const words = pickUniqueItems(symbols, length).picked;
        const question = new Question(EnumQuestionType.Direction4D);
    
        let wordCoordMap: Record<string, [number, number, number, number]> = {};
        let conclusionDirection = { spatial: "", temporal: "" };

        while (!conclusionDirection.spatial) {
            wordCoordMap = {};
            question.premises = [];
    
            for (let i = 0; i < words.length - 1; i++) {
                const timeIndex =  pickUniqueItems([-1,0,1], 1).picked[0];
                const timeName = TIME_NAMES[timeIndex + 1];
                const dirIndex = 1 + Math.floor(Math.random()*(DIRECTION_NAMES_3D.length - 1));
                const dirName = DIRECTION_NAMES_3D[dirIndex];
                const dirCoord = DIRECTION_COORDS_3D[dirIndex];

                if (i === 0) {
                    wordCoordMap[words[i]] = [0,0,0,0];
                }

                wordCoordMap[words[i+1]] = [
                    wordCoordMap[words[i]][0] + dirCoord[0], // x
                    wordCoordMap[words[i]][1] + dirCoord[1], // y
                    wordCoordMap[words[i]][2] + dirCoord[2], // z
                    wordCoordMap[words[i]][3] + timeIndex,   // time
                ];

                if (this.settings.enableNegation && coinFlip()) {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> ${timeName} <span class="is-negated">${(DIRECTION_NAMES_3D_INVERSE as any)[dirName]}</span> of <span class="subject">${words[i]}</span>`);
                } else {
                    question.premises.push(`<span class="subject">${words[i+1]}</span> ${timeName} ${dirName} of <span class="subject">${words[i]}</span>`);
                }
            }
    
            conclusionDirection = findDirection4D(wordCoordMap[words[0]], wordCoordMap[words[length-1]]);
        }

        question.wordCoordMap = wordCoordMap;
        question.isValid = coinFlip();
        const oppositeDirection = findDirection4D(wordCoordMap[words[length-1]], wordCoordMap[words[0]]);
        const direction = question.isValid ? conclusionDirection : oppositeDirection;

        if (this.settings.enableNegation && coinFlip()) {
            question.conclusion = `<span class="subject">${words[0]}</span> ${direction.temporal} <span class="is-negated">${(DIRECTION_NAMES_3D_INVERSE as any)[direction.spatial]}</span> of <span class="subject">${words[words.length-1]}</span>`;
        } else {
            question.conclusion = `<span class="subject">${words[0]}</span> ${direction.temporal} ${direction.spatial} of <span class="subject">${words[words.length-1]}</span>`;
        }

        shuffle(question.premises);
        
        return question;
    }

    createAnalogy(length: number) {
        if (length < 3) throw Error("Needs at least 3 premises.");

        const analogyEnables = [
            this.settings.distinction[0],
            this.settings.comparisonNumerical[0],
            this.settings.comparisonChronological[0],
            this.settings.direction[0],
            this.settings.direction3D[0],
            this.settings.direction4D[0]
        ];
        if (analogyEnables.reduce((a, c) => a + +c, 0) < 1) {
            throw new Error("Needs at least one of" + analogyEnables.join(", "));
        }

        const choiceIndices = [];
    
        if (this.settings.distinction[0]) {
            choiceIndices.push(0);
        }
        if (this.settings.comparisonNumerical[0]) {
            choiceIndices.push(1);
        }
        if (this.settings.comparisonChronological[0]) {
            choiceIndices.push(2);
        }
        if (this.settings.direction[0]) {
            choiceIndices.push(3);
        }
        if (this.settings.direction3D[0]) {
            choiceIndices.push(4);
        }
        if (this.settings.direction4D[0]) {
            choiceIndices.push(5);
        }
    
        const choiceIndex = pickUniqueItems(choiceIndices, 1).picked[0];

        let question = new Question(EnumQuestionType.Analogy);
        let isValidSame;
        let a, b, c, d;
        let indexOfA, indexOfB, indexOfC, indexOfD;

        const flip = coinFlip();

        switch (choiceIndex) {
            case 0:
                question = this.createDistinction(length);
                question.type = EnumQuestionType.Analogy;
                question.conclusion = "";
        
                [a, b, c, d] = pickUniqueItems([...question.buckets[0], ...question.buckets[1]], 4).picked;
                question.conclusion += `<span class="subject">${a}</span> to <span class="subject">${b}</span>`;

                [
                    indexOfA,
                    indexOfB,
                    indexOfC,
                    indexOfD
                ] = [
                    Number(question.buckets[0].indexOf(a) !== -1),
                    Number(question.buckets[0].indexOf(b) !== -1),
                    Number(question.buckets[0].indexOf(c) !== -1),
                    Number(question.buckets[0].indexOf(d) !== -1)
                ];
                isValidSame = (indexOfA === indexOfB && indexOfC === indexOfD) || (indexOfA !== indexOfB && indexOfC !== indexOfD);
                break;
            case 1:
            case 2:
                const type = choiceIndex === 1 ? EnumQuestionType.ComparisonNumerical : EnumQuestionType.ComparisonChronological;
                question = this.createComparison(length, type);
                question.type = EnumQuestionType.Analogy;
                question.conclusion = "";

                [a, b, c, d] = pickUniqueItems(question.bucket, 4).picked;
                question.conclusion += `<span class="subject">${a}</span> to <span class="subject">${b}</span>`;

                [indexOfA, indexOfB] = [question.bucket.indexOf(a), question.bucket.indexOf(b)];
                [indexOfC, indexOfD] = [question.bucket.indexOf(c), question.bucket.indexOf(d)];
                isValidSame = (indexOfA > indexOfB && indexOfC > indexOfD) || (indexOfA < indexOfB && indexOfC < indexOfD);
                break;
            case 3:
                while (flip !== isValidSame) {
                    question = this.createDirection(length);
                    question.type = EnumQuestionType.Analogy;
                    question.conclusion = "";

                    [a, b, c, d] = pickUniqueItems(Object.keys(question.wordCoordMap), 4).picked;
                    question.conclusion += `<span class="subject">${a}</span> to <span class="subject">${b}</span>`;
        
                    const dirA = findDirection(question.wordCoordMap[a] as any, question.wordCoordMap[b] as any);
                    const dirB = findDirection(question.wordCoordMap[c] as any, question.wordCoordMap[d] as any);
                    isValidSame = dirA === dirB;
                }
                break;
            case 4:
                while (flip !== isValidSame) {
                    question = this.createDirection3D(length);
                    question.type = EnumQuestionType.Analogy;
                    question.conclusion = "";

                    [a, b, c, d] = pickUniqueItems(Object.keys(question.wordCoordMap), 4).picked;
                    question.conclusion += `<span class="subject">${a}</span> to <span class="subject">${b}</span>`;

                    const dirA = findDirection3D(question.wordCoordMap[a] as any, question.wordCoordMap[b] as any);
                    const dirB = findDirection3D(question.wordCoordMap[c] as any, question.wordCoordMap[d] as any);
                    isValidSame = dirA === dirB;
                }
                break;
            case 5:
                while (flip !== isValidSame) {
                    question = this.createDirection4D(length);
                    question.type = EnumQuestionType.Analogy;
                    question.conclusion = "";

                    [a, b, c, d] = pickUniqueItems(Object.keys(question.wordCoordMap), 4).picked;
                    question.conclusion += `<span class="subject">${a}</span> to <span class="subject">${b}</span>`;

                    const { spatial, temporal } = findDirection4D(question.wordCoordMap[a] as any, question.wordCoordMap[b] as any);
                    const { spatial: spatial2, temporal: temporal2 } = findDirection4D(question.wordCoordMap[c] as any, question.wordCoordMap[d] as any);
                    isValidSame = (spatial === spatial2) && (temporal === temporal2);
                }
                break;
        }

        if (isValidSame === undefined) {
            throw new Error("Shouldn't be here...");
        }

        const isSameRelation = coinFlip();
        question.isValid = isSameRelation ? isValidSame : !isValidSame;

        if (this.settings.enableNegation && coinFlip()) {
            if (isSameRelation) {
                if (choiceIndex < 1) {
                    question.conclusion += '<div class="analogy-conclusion-relation is-negated">is different from</div>';
                } else {
                    question.conclusion += '<div class="analogy-conclusion-relation is-negated">has a different relation from</div>';
                }
            } else {
                if (choiceIndex < 1) {
                    question.conclusion += '<div class="analogy-conclusion-relation is-negated">is the same as</div>';
                } else {
                    question.conclusion += '<div class="analogy-conclusion-relation is-negated">has the same relation as</div>';
                }
            }
        } else {
            if (isSameRelation) {
                if (choiceIndex < 1) {
                    question.conclusion += '<div class="analogy-conclusion-relation">is the same as</div>';
                } else {
                    question.conclusion += '<div class="analogy-conclusion-relation">has the same relation as</div>';
                }
            } else {
                if (choiceIndex < 1) {
                    question.conclusion += '<div class="analogy-conclusion-relation">is different from</div>';
                } else {
                    question.conclusion += '<div class="analogy-conclusion-relation">has a different relation from</div>';
                }
            }
        }

        question.conclusion += `<span class="subject">${c}</span> to <span class="subject">${d}</span>`;
    
        return question;
    }

    createBinary(length: number) {
        if (length < 4) throw Error("Needs at least 4 premises.");

        const binaryEnables = [
            this.settings.distinction[0],
            this.settings.comparisonNumerical[0],
            this.settings.comparisonChronological[0],
            this.settings.direction[0],
            this.settings.direction3D[0],
            this.settings.direction4D[0],
            this.settings.syllogism[0]
        ];
        if (binaryEnables.reduce((a, c) => a + +c, 0) < 1) {
            throw new Error("Needs at least one of" + binaryEnables.join(", "));
        }

        const operands = [];
        const operandNames = [];
        const operandTemplates = [];
        const pool = [];
    
        if (this.settings.enableAnd) {
            operands.push("a&&b");
            operandNames.push("AND");
            operandTemplates.push('$a <div class="is-connector">and</div> $b');
        }
        if (this.settings.enableNand) {
            operands.push("!(a&&b)");
            operandNames.push("NAND");
            operandTemplates.push('$a <div class="is-connector">and</div> $b <div class="is-connector">are not both true</div>');
        }
        if (this.settings.enableOr) {
            operands.push("a||b");
            operandNames.push("OR");
            operandTemplates.push('$a <div class="is-connector">or</div> $b');
        }
        if (this.settings.enableNor) {
            operands.push("!(a||b)");
            operandNames.push("NOR");
            operandTemplates.push('$a <div class="is-connector">and</div> $b <div class="is-connector">are both false</div>');
        }
        if (this.settings.enableXor) {
            operands.push("!(a&&b)&&(a||b)");
            operandNames.push("XOR");
            operandTemplates.push('$a <div class="is-connector">differs from</div> $b');
        }
        if (this.settings.enableXnor) {
            operands.push("!(!(a&&b)&&(a||b))");
            operandNames.push("XNOR");
            operandTemplates.push('$a <div class="is-connector">is equal to</div> $b');
        }
    
        if (!operands.length) return;
    
        if (this.settings.syllogism[0]) {
            pool.push((length: number) =>
                this.createSyllogism(length)
            );
        }
        if (this.settings.distinction[0]) {
            pool.push((length: number) =>
                this.createDistinction(length)
            );
        }
        if (this.settings.comparisonNumerical[0]) {
            pool.push((length: number) =>
                this.createComparison(length, EnumQuestionType.ComparisonNumerical)
            );
        }
        if (this.settings.comparisonChronological[0]) {
            pool.push((length: number) =>
                this.createComparison(length, EnumQuestionType.ComparisonChronological)
            );
        }
        if (this.settings.direction[0]) {
            pool.push((length: number) =>
                this.createDirection(length)
            );
        }
        if (this.settings.direction3D[0]) {
            pool.push((length: number) =>
                this.createDirection3D(length)
            );
        }
        if (this.settings.direction4D[0]) {
            pool.push((length: number) =>
                this.createDirection4D(length)
            );
        }

        const question = new Question(EnumQuestionType.Binary);
        const flip = coinFlip();
        const operandIndex = Math.floor(Math.random()*operands.length);
        const operand = operands[operandIndex];

        do {
            const picked = pickUniqueItems(pool, 2).picked;
    
            const choices = [
                picked[0](Math.floor(length / 2)),
                picked[1](Math.ceil(length / 2))
            ];
        
            question.premises = [...choices[0].premises, ...choices[1].premises];
            shuffle(question.premises);
        
            question.conclusion = operandTemplates[operandIndex]
                .replace("$a", choices[0].conclusion)
                .replace("$b", choices[1].conclusion);

            question.isValid = eval(
                operand
                    .replaceAll("a", String(choices[0].isValid))
                    .replaceAll("b", String(choices[1].isValid))
            );
        } while (flip !== question.isValid);
    
        return question;
    }
}

================
File: src/app/syllogimous/syllogimous.component.html
================
<router-outlet class="d-none"></router-outlet>

================
File: src/app/syllogimous/syllogimous.component.scss
================
:host {
    display: grid;
    place-items: center;
    height: 100svh;
    background-color: #8EC5FC;
    background-image: linear-gradient(62deg, #8EC5FC 0%, #E0C3FC 100%);
    background-size: cover;
}

================
File: src/app/syllogimous/syllogimous.component.ts
================
import { Component, HostBinding } from "@angular/core";

@Component({
    selector: "app-syllogimous",
    templateUrl: "./syllogimous.component.html",
    styleUrls: ["./syllogimous.component.scss"]
})
export class SyllogimousComponent {
    @HostBinding('style.backgroundImage') backgroundImage = `linear-gradient(62deg, #8EC5FC88 0%, #E0C3FC88 100%), url(assets/images/bg-${1 + Math.floor(Math.random() * 6)}.avif)`;
}

================
File: src/app/syllogimous/syllogimous.module.ts
================
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, Routes } from '@angular/router';
import { SyllogimousComponent } from './syllogimous.component';
import { SharedModule } from 'src/app/shared/shared.module';
import { ModalLevelChangeComponent } from './components/modal-level-change/modal-level-change.component';
import { CardComponent } from './components/card/card.component';
import { IntroComponent } from './pages/intro/intro.component';
import { StartComponent } from './pages/start/start.component';
import { TutorialComponent } from './pages/tutorial/tutorial.component';
import { HistoryComponent } from './pages/history/history.component';
import { GameComponent } from './pages/game/game.component';
import { FeedbackComponent } from './pages/feedback/feedback.component';
import { StatsComponent } from './pages/stats/stats.component';
import { TutorialsComponent } from './pages/tutorials/tutorials.component';
import { EnumScreens } from './models/syllogimous.models';
import { TutorialDistinctionComponent } from './pages/tutorial/distinction/distinction.component';
import { TutorialSyllogismComponent } from './pages/tutorial/syllogism/syllogism.component';
import { TutorialComparisonNumericalComponent } from './pages/tutorial/comparison-numerical/comparison-numerical.component';
import { TutorialComparisonChronologicalComponent } from './pages/tutorial/comparison-chronological/comparison-chronological.component';
import { TutorialDirectionComponent } from './pages/tutorial/direction/direction.component';
import { TutorialDirection3DComponent } from './pages/tutorial/direction3D/direction3D.component';
import { TutorialDirection4DComponent } from './pages/tutorial/direction4D/direction4D.component';
import { TutorialAnalogyComponent } from './pages/tutorial/analogy/analogy.component';
import { TutorialBinaryComponent } from './pages/tutorial/binary/binary.component';
import { EnumQuestionType } from './models/question.models';
import { AccuracyStatsComponent } from './pages/stats/accuracy-stats/accuracy-stats.component';
import { ErrorAnalysisComponent } from './pages/stats/error-analysis/error-analysis.component';
import { TierStatsComponent } from './pages/stats/tier-stats/tier-stats.component';
import { TimeBasedStatsComponent } from './pages/stats/time-based-stats/time-based-stats.component';
import { TypeBasedStatsComponent } from './pages/stats/type-based-stats/type-based-stats.component';

const routes: Routes = [
  {
    path: '',
    component: SyllogimousComponent,
    children: [
      { path: "", redirectTo: EnumScreens.Intro, pathMatch: "full" },
      { path: EnumScreens.Intro, component: IntroComponent },
      { path: EnumScreens.Start, component: StartComponent },
      { path: EnumScreens.Game, component: GameComponent },
      { path: EnumScreens.History, component: HistoryComponent },
      { path: EnumScreens.Feedback, component: FeedbackComponent },
      { path: EnumScreens.Tutorials, component: TutorialsComponent },
      { 
        path: EnumScreens.Tutorial,
        component: TutorialComponent,
        children: [
          { path: EnumQuestionType.Distinction, component: TutorialDistinctionComponent },
          { path: EnumQuestionType.Syllogism, component: TutorialSyllogismComponent },
          { path: EnumQuestionType.ComparisonNumerical, component: TutorialComparisonNumericalComponent },
          { path: EnumQuestionType.ComparisonChronological, component: TutorialComparisonChronologicalComponent },
          { path: EnumQuestionType.Direction, component: TutorialDirectionComponent },
          { path: EnumQuestionType.Direction3D, component: TutorialDirection3DComponent },
          { path: EnumQuestionType.Direction4D, component: TutorialDirection4DComponent },
          { path: EnumQuestionType.Analogy, component: TutorialAnalogyComponent },
          { path: EnumQuestionType.Binary, component: TutorialBinaryComponent },
        ]
      },
      { path: EnumScreens.Stats, component: StatsComponent },
    ]
  }
];

@NgModule({
  declarations: [
    SyllogimousComponent,
    CardComponent,
    ModalLevelChangeComponent,
    IntroComponent,
    StartComponent,
    HistoryComponent,
    GameComponent,
    FeedbackComponent,
    TutorialsComponent,
    TutorialComponent,
    TutorialDistinctionComponent,
    TutorialSyllogismComponent,
    TutorialComparisonNumericalComponent,
    TutorialComparisonChronologicalComponent,
    TutorialDirectionComponent,
    TutorialDirection3DComponent,
    TutorialDirection4DComponent,
    TutorialAnalogyComponent,
    TutorialBinaryComponent,
    StatsComponent,
    AccuracyStatsComponent,
    ErrorAnalysisComponent,
    TierStatsComponent,
    TimeBasedStatsComponent,
    TypeBasedStatsComponent
  ],
  imports: [
    CommonModule,
    SharedModule,
    RouterModule.forChild(routes),
  ]
})
export class SyllogimousModule { }

================
File: src/app/syllogimous/utils/engine.utils.ts
================
import { DIRECTION_COORDS, DIRECTION_COORDS_3D, DIRECTION_NAMES, DIRECTION_NAMES_3D, FORMS, NOUNS, STRINGS, TIME_NAMES, VALID_RULES } from "../constants/engine.constants";
import { EnumQuestionType, Question } from "../models/question.models";
import { ISettings, Picked } from "../models/settings.models";

export function genBinKey(booleans: boolean[]) {
    return booleans.map(value => (value ? '1' : '0')).join('');
}

export function coinFlip() {
    return Math.random() > 0.5;
}

export function pickUniqueItems<T>(array: T[], n: number): Picked<T> {
    const copy = [...array];
    const picked = [];
    while (n > 0) {
        const rnd = Math.floor(Math.random() * copy.length);
        picked.push(copy.splice(rnd, 1)[0]);
        n--;
    }
    return { picked, remaining: copy };
}

export function shuffle<T>(array: T[]) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex != 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
}

export function getDirectionString(x: number, y: number, z: number) {
    let res = "";
    if (z === 1) res = "Above";
    if (z === -1) res = "Below";
    if (z && (x || y)) res += " and ";
    if (y === 1) res += "North";
    if (y === -1) res += "South";
    if (y && x) res += "-";
    if (x === 1) res += "East";
    if (x === -1) res += "West";
    return res;
}

export function findDirection(aCoord: [number, number], bCoord: [number, number]) {
    const x = aCoord[0];
    const y = aCoord[1];
    const x2 = bCoord[0];
    const y2 = bCoord[1];

    const dx = ((x - x2) / Math.abs(x - x2)) || 0;
    const dy = ((y - y2) / Math.abs(y - y2)) || 0;

    const dirIndex = DIRECTION_COORDS.findIndex(c => c[0] === dx && c[1] === dy);
    const dirName = DIRECTION_NAMES[dirIndex];

    return dirName!;
}

export function findDirection3D(aCoord: [number, number, number], bCoord: [number, number, number]) {
    const x = aCoord[0];
    const y = aCoord[1];
    const z = aCoord[2];
    const x2 = bCoord[0];
    const y2 = bCoord[1];
    const z2 = bCoord[2];

    const dx = ((x - x2) / Math.abs(x - x2)) || 0;
    const dy = ((y - y2) / Math.abs(y - y2)) || 0;
    const dz = ((z - z2) / Math.abs(z - z2)) || 0;

    const dirIndex = DIRECTION_COORDS_3D.findIndex(c => c[0] === dx && c[1] === dy && c[2] === dz);
    const dirName = DIRECTION_NAMES_3D[dirIndex];
    return dirName;
}

export function findDirection4D(aCoord: [number, number, number, number], bCoord: [number, number, number, number]) {
    const a = aCoord[3];
    const a2 = bCoord[3];

    return {
        spatial: findDirection3D(aCoord as any, bCoord as any),
        temporal: TIME_NAMES[Math.sign(a-a2) + 1]
    };
}

export function getRandomRuleValid() {
    return VALID_RULES[Math.floor(Math.random() * VALID_RULES.length)];
}

export function getRandomRuleInvalid() {
    let rule;
    while (!rule || VALID_RULES.includes(rule)) {
        rule = "";
        for (let i = 0; i < 3; i++) {
            rule += Math.floor(Math.random() * 4); // Form
        }
        rule += 1 + Math.floor(Math.random() * 4); // Figure
    }
    return rule;
}

export function extractSubjects(phrase: string) {
    return [...phrase.matchAll(/<span class="subject">(.*?)<\/span>/g)].map(a => a[1]);
}

export function isPremiseLikeConclusion(premises: string[], conclusion: string) {
    const subjectsOfPremises = premises.map(p => extractSubjects(p));
    const subjectsOfConclusion = extractSubjects(conclusion);
    for (const subjects of subjectsOfPremises) {
        const toCompare = subjectsOfConclusion[0]+subjectsOfConclusion[1];
        if (subjects[0]+subjects[1] === toCompare || subjects[1]+subjects[0] === toCompare)
            return true;
    }
    return false;
}

export function getSymbols(settings: ISettings) {
    return settings.enableMeaningfulWords ? [...NOUNS] : [...STRINGS];
}

export function getRandomSymbols(settings: ISettings, length: number) {
    const symbols = getSymbols(settings);
    const seen = new Set();
    return Array(length).fill(0)
            .map(() => {
                let rnd = Math.floor(Math.random() * symbols.length);
                while (seen.has(rnd)) {
                    rnd = Math.floor(Math.random() * symbols.length);
                }
                seen.add(rnd);
                return symbols[rnd];
            });
}

export function getSyllogism(settings: ISettings, s: string, p: string, m: string, rule: string) {
    
    const _forms = (!settings.enableNegation)
        ? FORMS[0]
        : pickUniqueItems(FORMS, 1).picked[0];

    let major = _forms[+rule[0]];
    let minor = _forms[+rule[1]];
    let conclusion = _forms[+rule[2]];

    const figure = +rule[3];
    switch (figure) {
        case 1:
            major = major.replace("$", m);
            major = major.replace("$", p);
            minor = minor.replace("$", s);
            minor = minor.replace("$", m);
            break;
        case 2:
            major = major.replace("$", p);
            major = major.replace("$", m);
            minor = minor.replace("$", s);
            minor = minor.replace("$", m);
            break;
        case 3:
            major = major.replace("$", m);
            major = major.replace("$", p);
            minor = minor.replace("$", m);
            minor = minor.replace("$", s);
            break;
        case 4:
            major = major.replace("$", p);
            major = major.replace("$", m);
            minor = minor.replace("$", m);
            minor = minor.replace("$", s);
            break;
    }

    conclusion = conclusion.replace("$", s);
    conclusion = conclusion.replace("$", p);

    return [major, minor, conclusion];
}

export function getMetaReplacer(settings: ISettings, choosenPair: Picked<string>, relations: string[], negations: boolean[]) {
    const choosenSubjects = [...choosenPair.picked[0].matchAll(/<span class="subject">(.*?)<\/span>/g)];
    const [a, b] = choosenSubjects.map(m => m[1]);

    const isSameAs = (relations[0] === relations[1]) === (negations[0] === negations[1]);
    const relation = getRelation(settings, EnumQuestionType.Distinction, isSameAs);

    return `$1 ${relation} (<span class="subject">${a}</span> to <span class="subject">${b}</span>) to `;
}

export function getRelation(settings: ISettings, type: EnumQuestionType, isPositive: boolean) {
    let positive = "";
    let negative = "";

    switch (type) {
        case EnumQuestionType.Distinction:
            positive = "same as";
            negative = "opposite of";
            break;
        case EnumQuestionType.ComparisonNumerical:
            positive = "more than";
            negative = "less than";
            break;
        case EnumQuestionType.ComparisonChronological:
            positive = "after";
            negative = "before";
            break;
    }

    let relation = isPositive ? positive : negative;
    if (settings.enableNegation && coinFlip()) {
        switch (relation) {
            case positive:
                relation = `<span class="is-negated">${negative}</span>`;
                break;
            case negative:
                relation = `<span class="is-negated">${positive}</span>`;
                break;
        }
    }
    return relation;
}

export function makeMetaRelations(settings: ISettings, question: Question, length: number) {
    if (settings.enableMeta && coinFlip()) {
        const numOfMetaRelations = 1 + Math.floor(Math.random() * Math.floor((length - 1) / 2));
        let _premises = pickUniqueItems(question.premises, numOfMetaRelations * 2);
        question.premises = [ ..._premises.remaining ];
    
        while (_premises.picked.length) {
            const choosenPair = pickUniqueItems(_premises.picked, 2);
            const negations = choosenPair.picked.map(p => /is-negated/.test(p));
            const relations = choosenPair.picked.map(p => p.match(/is (?:<span class="is-negated">)*(.*?)(?:<\/span>)* /)![1]);
    
            const replacer = getMetaReplacer(settings, choosenPair, relations, negations);
            const newPremise = choosenPair.picked[1].replace(/(is) (.*)(?=<span class="subject">)/, replacer);
    
            question.premises.push(choosenPair.picked[0], newPremise);
    
            _premises = { picked: choosenPair.remaining, remaining: [] };
        }
    }
}

================
File: src/app/utils/array.ts
================
export function intersection(a: any[], b: any[]) {
    return a.filter(v => b.includes(v));
}

export function dedupe<T>(a: T[], key: string) {

    if (!a || !Array.isArray(a) || !key)
        return [];

    const freqMap: { [key: string | number]: T } = {};

    a.forEach((x: any) => freqMap[x[key]] = x);

    return Object.values(freqMap);
}

export function emptyArray(array: any[]) {
    array.splice(0, array.length);
    return array;
}

export function replaceItems(array: any[], newItems: any[]) {
    emptyArray(array).push(...newItems);
    return array;
}

================
File: src/app/utils/date.ts
================
import { NgbDateStruct } from "@ng-bootstrap/ng-bootstrap";
import { MonthpickerStruct } from "../shared/components/monthpicker/monthpicker.component";

export function isoToStruct(iso: string): NgbDateStruct | null {

    if (!iso || !/\d{4}-[01]\d-[0-3]\d/.test(iso))
        return null;

    const [ year, month, day ] = [+iso.slice(0, 4), +iso.slice(5, 7), +iso.slice(8, 10)];
    return { year, month, day };
}

export function structToIso(struct: NgbDateStruct | MonthpickerStruct): string | null {

    if (!struct || !struct.year || !struct.month)
        return null;

    const yyyy = struct.year;
    const MM = (struct.month + "").padStart(2, "0");

    let dd = "01";
    if ("day" in struct)
        dd = (struct.day + "").padStart(2, "0");

    return yyyy + "-" + MM + "-" + dd;
}

export function formatTime(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
  
    const remainingSeconds = seconds % 60;
    const remainingMinutes = minutes % 60;
  
    const formattedHours = hours.toString().padStart(2, '0');
    const formattedMinutes = remainingMinutes.toString().padStart(2, '0');
    const formattedSeconds = remainingSeconds.toString().padStart(2, '0');
    return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
}

================
File: src/app/utils/dom.ts
================
export function delayedScrollTo(queryString: string, ms?: number) {
    ms = ms || 150;
    setTimeout(
        () =>
            document.querySelector(queryString)
                ?.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                }),
        ms
    );
}

export function blur() {
    (document.activeElement as any)?.blur();
}

================
File: src/app/utils/file.ts
================
export function downloadFile(result: Blob | ArrayBuffer, fileNameWithExt: string, customType?: string) {
    const link = document.createElement("A") as HTMLAnchorElement;
    const file = new Blob([ result ], { type: customType || "text/plain" });
    link.href = URL.createObjectURL(file);
    link.download = fileNameWithExt;
    link.click();
    URL.revokeObjectURL(link.href);
}

export function downloadFromURL(url: string) {
    const dl = document.createElement("a");
    dl.target = "_blank";
    dl.download = url;
    dl.href = url;
    dl.click();
}

================
File: src/app/utils/input.ts
================
export function enforceMinMax(el: HTMLInputElement, minOverride?: number, maxOverride?: number) {

  const min = (minOverride !== undefined) ? minOverride : parseFloat(el.min);
  const max = (maxOverride !== undefined) ? maxOverride : parseFloat(el.max);

  if (el.value !== "") {

    if (parseFloat(el.value) < min)
      el.value = min.toString();

    if (parseFloat(el.value) > max)
      el.value = max.toString();
  }
}

================
File: src/app/utils/json.ts
================
export function jsonCopy(obj: Object) {
    return JSON.parse(JSON.stringify(obj));
}

export function parseJwt(token: string) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace('-', '+').replace('_', '/');
    return JSON.parse(atob(base64));
}

================
File: src/app/utils/mask.ts
================
import createNumberMask from "../shared/directives/deps/text2mask/createNumberMask";

export interface NumberMaskOptions {
    prefix?: string;
    suffix?: string;
    allowDecimal?: boolean;
    allowNegative?: boolean;
    integerLimit?: number;
    decimalLimit?: number;
    thousandsSeparatorSymbol?: "." | ",";
    decimalSymbol?: "." | ",";
}

export interface NumberMaskConfig extends NumberMaskOptions {
    prefix: string;
    suffix: string;
    thousandsSeparatorSymbol: "." | ",";
    decimalSymbol: "." | ",";
}

export class NumberMask {

    private config: NumberMaskConfig;
    private numberMask: any;

    constructor(opts?: NumberMaskOptions) {

        // DO NOT touch the default values
        this.config = {
            prefix:                     opts?.prefix                    || "",
            suffix:                     opts?.suffix                    || "",
            allowNegative:              opts?.allowNegative             || false,
            allowDecimal:               opts?.allowDecimal              || true,
            integerLimit:               opts?.integerLimit              || 6,
            decimalLimit:               opts?.decimalLimit              || 2,
            thousandsSeparatorSymbol:   opts?.thousandsSeparatorSymbol  || ".",
            decimalSymbol:              opts?.decimalSymbol             || ","
        };

        if (this.config?.thousandsSeparatorSymbol === this.config?.decimalSymbol) {
            throw new Error("NumberMask: thousandsSeparatorSymbol cannot be the same as decimalSymbol.");
        }
        
        this.numberMask = createNumberMask({ ...this.config });
    }

    getMask() {
        return this.numberMask;
    }

    numberToMask(num?: number | null) {
        const numStr = num ? (num + "") : "0"; // Cast number to string or "0"
        return this.numStrToMask(numStr);
    }

    numStrToMask(unmasked?: string | null) {

        const [ prefix, suffix, thousandsSeparator, decimal ] = [
            this.config.prefix,
            this.config.suffix,
            this.config.thousandsSeparatorSymbol,
            this.config.decimalSymbol,
        ];

        unmasked = unmasked || ""; // Guard against falsy values
        
        return prefix + unmasked.replace(thousandsSeparator, decimal) + suffix;
    }

    maskToNumber(numStr?: string | null) {
        const fixed = this.config.prefix + "0" + this.config.suffix;
        return parseFloat(this.maskToNumStr(numStr || fixed));
    }

    maskToNumStr(masked: string) {
        // Remove prefix and suffix
        const fixRemoved = masked.replace(this.config.prefix, "").replace(this.config.suffix, "");
        // If comma is the decimal separator, then remove dots and replace comma with dot
        if (this.config.decimalSymbol === ",") {
            return fixRemoved.replaceAll(".", "").replace(",", ".");
        }
        // Else dot is the decimal separator, so only remove the commas
        return fixRemoved.replaceAll(",", "");
    }
}

================
File: src/app/utils/number.ts
================
export function isNumeric(value: any) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}

================
File: src/app/utils/object.ts
================
export function resolve(path: string, obj = self, separator = '.') {
    const properties = path.split(separator);
    return properties.reduce((prev: any, curr: any) => prev?.[curr], obj);
};

export function lookmap<V>(key: string | number, array: V[]): { [key: string | number]: V[] }  {
    return array
        .reduce(
            (a, b) => {

                const _b = b as any;

                a[_b[key]] = a[_b[key]] || [];
                a[_b[key]].push(b);

                return a;
            },
            {} as { [key: string | number]: V[] }
        );
}

export function singlifyLookmap<V>(input: { [key: string | number]: V[] }): { [key: string | number]: V } {
    const result = {} as { [key: string | number]: V };
    Object.keys(input).forEach(key => result[key] = input[key][0]);
    return result;
}

export function emptyObject(object: any) {

    if (typeof object !== "object")
        throw new Error("Argument object of emptyObject is not an object.");
    
    for (const key in object) {
        delete object[key];
    }
    return object;
}

export function replaceProps(object: any, props: any) {

    if (typeof object !== "object")
        throw new Error("Argument object of replaceProps is not an object.");

    if (typeof props !== "object")
        throw new Error("Argument props of replaceProps is not an object.");

    return Object.assign(object, props);
}

================
File: src/app/utils/promise.ts
================
export function delay(ms: number) {
    return new Promise(res => setTimeout(() => res(1), ms));
}

================
File: src/app/utils/uuid.ts
================
export function guid() {
    return Math.random().toString(36).substring(2, 15)
         + Math.random().toString(36).substring(2, 15);
}

export function suid(length = 40) {
    return Math.random().toString(36).substring(2, 2 + Math.floor(length / 2))
         + Math.random().toString(36).substring(2, 2 + Math.round(length / 2));
}

================
File: src/assets/css/custom-styles/base.css
================
/* Start of VARIABLES */
@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');

:root {
    --app-body-background: var(--app-gray_100);
    --app-sidebar-gradient: linear-gradient(135deg, rgba(var(--app-blue_400), 1), rgba(var(--app-indigo_400), 1));
    --flexgrid-col-min-width: 20ch;
    --flexgrid-gap: 1rem;
}
/* End of VARIABLES */


/* Start of RESETS */
body {
    background: rgba(var(--app-body-background), 1);
    font-family: "Roboto", var(--bs-font-sans-serif);
}

ngb-typeahead-window {
    width: 100%;
    max-height: 450px;
    overflow: auto;
}

ngb-typeahead-window .dropdown-item {
    white-space: initial;
}

.pagination {
    margin-bottom: 0 !important;
}
/* End of RESETS */

================
File: src/assets/css/custom-styles/layout.css
================
/* Start of FLEXGRID */
.flexgrid {
    display: flex;
    flex-wrap: wrap;
    margin: 0 calc(-1 * var(--flexgrid-gap) / 2);
}

.flexgrid--no-grow > * {
    flex-grow: 0 !important;
}

.flexgrid > * {
    flex: 1 1 clamp(var(--flexgrid-col-min-width), 100%, 100%);
    padding: calc(var(--flexgrid-gap) / 2);
}

.flexgrid--2 > * {
    flex: 1 1 clamp(var(--flexgrid-col-min-width), 50%, 50%);
    padding: calc(var(--flexgrid-gap) / 2);
}

.flexgrid--3 > * {
    flex: 1 1 clamp(var(--flexgrid-col-min-width), 33.33%, 33.33%);
    padding: calc(var(--flexgrid-gap) / 2);
}

.flexgrid--4 > * {
    flex: 1 1 clamp(var(--flexgrid-col-min-width), 25%, 25%);
    padding: calc(var(--flexgrid-gap) / 2);
}

.flexgrid--5 > * {
    flex: 1 1 clamp(var(--flexgrid-col-min-width), 20%, 20%);
    padding: calc(var(--flexgrid-gap) / 2);
}
/* End of FLEXGRID */


/* Start of WIZARD */
.wiz {
    width: 100%;
    display: flex;
    flex-wrap: nowrap;
    isolation: isolate;
    padding: 0.5rem 0;
}

.wiz__step {
    background: rgba(var(--app-primary_500), 0.6);
    color: rgba(var(--app-gray_0), 1) !important;
    cursor: pointer;
    flex: 1 1 250px;
    padding: 1rem 2rem;
    clip-path: polygon(0 0, calc(100% - 1rem) 0, 100% 50%, calc(100% - 1rem) 100%, 0 100%);
    transition: all 400ms ease;
}

.wiz__step {
    clip-path: polygon(0 0, calc(100% - 1rem) 0, 100% 50%, calc(100% - 1rem) 100%, 0 100%, 1rem 50%);
}

.wiz__step:not(.disabled):hover {
    transform: scale(1.05);
}

.wiz__step:has(~ .active) {
    background: rgba(var(--app-primary_500), 0.9);
}

.wiz__step:has(~ .active) .wiz__title::before {
    content: "\2713";
    margin-right: 0.25rem;
}

.wiz__step.active {
    background: rgba(var(--app-primary_600), 1);
}

.wiz__step.disabled {
    background: rgba(var(--app-gray_500), 0.5);
}

.wiz__title {
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 0.25rem;
}

@media (max-width: 768px) {

    .wiz {
        display: grid;
    }

    .wiz__step {
        padding: 0.25rem;
        clip-path: unset !important;
        margin-left: unset !important;
        text-align: center;
    }

    .wiz__descr {
        display: none;
    }
}
/* End of WIZARD */

================
File: src/assets/css/custom-styles/module.css
================
/* Start of BRAND */
.app-brand {
    align-items: center;
    color: inherit !important;
    display: flex;
    font-size: 1.33rem;
    gap: 0.75rem;
    margin-right: var(--bs-navbar-brand-margin-end);
    text-decoration: none;
    white-space: nowrap;
}

.app-brand > .pic {
    width: 40px;
    height: 40px;
}
/* End of BRAND */


/* Start of NAVBAR */
.app-navbar {
    min-height: 64px;
    border-bottom: 1px solid rgba(var(--app-gray_100), 1);
}
/* End of NAVBAR */


/* Start of BUTTON */
.btn-circle {
    width: 42px;
    height: 42px;
    line-height: 1;
    border-radius: 50%;
}

.btn-circle.btn-lg {
    width: 54px;
    height: 54px;
}
/* End of BUTTON */


/* Start of CDK_DRAG */
.cdk-drag-preview {
    box-sizing: border-box;
    border-radius: 4px;
    box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2),
        0 8px 10px 1px rgba(0, 0, 0, 0.14),
        0 3px 14px 2px rgba(0, 0, 0, 0.12);
}

.cdk-drag-placeholder {
    opacity: 0;
}

.cdk-drag-animating {
    transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);
}

*.cdk-drop-list-dragging *:not(.cdk-drag-placeholder) {
    transform: translateZ(0);
    transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);
}

.cdk-drag-preview {
    z-index: 9000 !important;
}
/* End of CDK_DRAG */


/* Start of TABLE */
th[sortable] {
    cursor: pointer;
    user-select: none;
}

th[sortable]::before {
    content: '\F3CA';
    display: inline-block;
    font-family: bootstrap-icons !important;
    font-style: normal;
    font-weight: normal !important;
    font-variant: normal;
    text-transform: none;
    line-height: 1;
    margin-right: 4px;
    vertical-align: -0.125em;
}

th[sortable].desc::before,
th[sortable].asc::before {
    content: '\F57B';
}

th[sortable].desc::before {
    content: '\F575';
}
/* End of TABLE */

================
File: src/assets/css/custom-styles/util.css
================
.lh-0 {
    line-height: 0 !important;
}

.no-text-break {
    white-space: nowrap;
}

.clickable {
    cursor: pointer;
    user-select: none;
}

.not-clickable {
    cursor: not-allowed;
    pointer-events: none;
}

.pseudo-disabled {
    background-color: rgba(var(--app-gray_50), 1);
    cursor: not-allowed;
    pointer-events: none;
}

================
File: src/environments/environment.ts
================
// This file is replaced following the specifications contained in the angular.json file
import { EnumEnvs } from "./envs";
import { versions } from './versions';

export const environment = {
	name: EnumEnvs.Development,
	bootstrap: versions['bootstrap'],
	ngBootstrap: versions['ngBootstrap'],
};

================
File: src/environments/envs.ts
================
export enum EnumEnvs {
    Development = "development",
    UAT = "uat",
    Production = "production"
}

================
File: src/environments/versions.ts
================
declare var require: any

const bootstrap: string = require('../../package.json').dependencies['bootstrap']
    .replace('^', '')
    .split('.')
    .slice(0, 2)
    .join('.'); // extracts only the minor version "4.0.1" -> "4.0"

const ngBootstrap: string = require('../../package.json').dependencies['@ng-bootstrap/ng-bootstrap']
    .replace('^', '')
    .split('.')
    .slice(0, 2)
    .map((v: string, i: number) => i === 1 ? "x" : v)
    .join('.'); // extracts only the major and blank minor with x "4.0.1" -> "4.x"

export const versions: { [key: string]: string } = {
    bootstrap,
    ngBootstrap
};

================
File: src/index.html
================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Syllogimous v4</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="android-chrome-512x512.png">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
</head>
<body>
  <app-root></app-root>
</body>
</html>

================
File: src/main.ts
================
/// <reference types="@angular/localize" />

import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';


platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));

================
File: src/styles.css
================
/* Start of VARIABLES */
:root {
    --border-radius_sm: calc(var(--border-radius_md) * 0.2 / 0.25);
    --border-radius_md: 1.1rem;
    --border-radius_lg: calc(var(--border-radius_md) * 0.3 / 0.25);
}
/* End of VARIABLES */

.flex-between {
    display: flex;
    justify-content: space-between;
}

================
File: tsconfig.app.json
================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "@angular/localize"
    ]
  },
  "files": [
    "src/main.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}

================
File: tsconfig.json
================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "sourceMap": true,
    "declaration": false,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "useDefineForClassFields": false,
    "lib": [
      "ES2022",
      "dom"
    ]
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}

================
File: tsconfig.spec.json
================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine",
      "@angular/localize"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}
